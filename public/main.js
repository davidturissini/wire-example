/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@lwc/engine/dist/modules/es2017/engine.js":
/*!****************************************************************!*\
  !*** ./node_modules/@lwc/engine/dist/modules/es2017/engine.js ***!
  \****************************************************************/
/*! exports provided: createElement, getComponentDef, isComponentConstructor, getComponentConstructor, LightningElement, register, unwrap, registerTemplate, sanitizeAttribute, registerComponent, registerDecorators, isNodeFromTemplate, dangerousObjectMutation, api, track, readonly, wire, decorate, buildCustomElementConstructor, Element */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createElement\", function() { return createElement$2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getComponentDef\", function() { return getComponentDef; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isComponentConstructor\", function() { return isComponentConstructor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getComponentConstructor\", function() { return getComponentConstructor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LightningElement\", function() { return BaseLightningElement; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"register\", function() { return register; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unwrap\", function() { return unwrap$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registerTemplate\", function() { return registerTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sanitizeAttribute\", function() { return sanitizeAttribute; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registerComponent\", function() { return registerComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registerDecorators\", function() { return registerDecorators; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNodeFromTemplate\", function() { return isNodeFromTemplate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dangerousObjectMutation\", function() { return dangerousObjectMutation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"api\", function() { return api; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"track\", function() { return track; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"readonly\", function() { return readonly; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wire\", function() { return wire; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decorate\", function() { return decorate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildCustomElementConstructor\", function() { return buildCustomElementConstructor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Element\", function() { return BaseLightningElement; });\n/* proxy-compat-disable */\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { freeze, seal, keys, create, assign, defineProperty, getPrototypeOf, setPrototypeOf, getOwnPropertyDescriptor, getOwnPropertyNames, defineProperties, getOwnPropertySymbols, hasOwnProperty, preventExtensions, isExtensible, } = Object;\nconst { isArray } = Array;\nconst { concat: ArrayConcat, filter: ArrayFilter, slice: ArraySlice, splice: ArraySplice, unshift: ArrayUnshift, indexOf: ArrayIndexOf, push: ArrayPush, map: ArrayMap, join: ArrayJoin, forEach, reduce: ArrayReduce, reverse: ArrayReverse, } = Array.prototype;\nconst { replace: StringReplace, toLowerCase: StringToLowerCase, indexOf: StringIndexOf, charCodeAt: StringCharCodeAt, slice: StringSlice, split: StringSplit, } = String.prototype;\nfunction isUndefined(obj) {\n    return obj === undefined;\n}\nfunction isNull(obj) {\n    return obj === null;\n}\nfunction isTrue(obj) {\n    return obj === true;\n}\nfunction isFalse(obj) {\n    return obj === false;\n}\nfunction isFunction(obj) {\n    return typeof obj === 'function';\n}\nfunction isObject(obj) {\n    return typeof obj === 'object';\n}\nfunction isString(obj) {\n    return typeof obj === 'string';\n}\nfunction isNumber(obj) {\n    return typeof obj === 'number';\n}\nconst OtS = {}.toString;\nfunction toString(obj) {\n    if (obj && obj.toString) {\n        return obj.toString();\n    }\n    else if (typeof obj === 'object') {\n        return OtS.call(obj);\n    }\n    else {\n        return obj + '';\n    }\n}\nfunction getPropertyDescriptor(o, p) {\n    do {\n        const d = getOwnPropertyDescriptor(o, p);\n        if (!isUndefined(d)) {\n            return d;\n        }\n        o = getPrototypeOf(o);\n    } while (o !== null);\n}\nconst emptyString = '';\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { addEventListener, removeEventListener, hasAttribute, getAttribute, getAttributeNS, setAttribute, setAttributeNS, removeAttribute, removeAttributeNS, querySelector, querySelectorAll, getBoundingClientRect, getElementsByTagName, getElementsByClassName, getElementsByTagNameNS, } = Element.prototype;\nconst innerHTMLSetter = hasOwnProperty.call(Element.prototype, 'innerHTML') ?\n    getOwnPropertyDescriptor(Element.prototype, 'innerHTML').set :\n    getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML').set; // IE11\nconst tagNameGetter = getOwnPropertyDescriptor(Element.prototype, 'tagName').get;\nconst tabIndexGetter = getOwnPropertyDescriptor(HTMLElement.prototype, 'tabIndex').get;\nconst matches = hasOwnProperty.call(Element.prototype, 'matches') ?\n    Element.prototype.matches :\n    Element.prototype.msMatchesSelector; // IE11\nconst childrenGetter = hasOwnProperty.call(Element.prototype, 'innerHTML') ?\n    getOwnPropertyDescriptor(Element.prototype, 'children').get :\n    getOwnPropertyDescriptor(HTMLElement.prototype, 'children').get; // IE11\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { DOCUMENT_POSITION_CONTAINED_BY, DOCUMENT_POSITION_CONTAINS, DOCUMENT_POSITION_PRECEDING, DOCUMENT_POSITION_FOLLOWING, DOCUMENT_FRAGMENT_NODE, } = Node;\nconst { insertBefore, removeChild, appendChild, hasChildNodes, replaceChild, compareDocumentPosition, cloneNode, } = Node.prototype;\nconst parentNodeGetter = getOwnPropertyDescriptor(Node.prototype, 'parentNode').get;\nconst parentElementGetter = hasOwnProperty.call(Node.prototype, 'parentElement') ?\n    getOwnPropertyDescriptor(Node.prototype, 'parentElement').get :\n    getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement').get; // IE11\nconst textContextSetter = getOwnPropertyDescriptor(Node.prototype, 'textContent').set;\nconst childNodesGetter = hasOwnProperty.call(Node.prototype, 'childNodes') ?\n    getOwnPropertyDescriptor(Node.prototype, 'childNodes').get :\n    getOwnPropertyDescriptor(HTMLElement.prototype, 'childNodes').get; // IE11\nconst nodeValueDescriptor = getOwnPropertyDescriptor(Node.prototype, 'nodeValue');\nconst nodeValueSetter = nodeValueDescriptor.set;\nconst nodeValueGetter = nodeValueDescriptor.get;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ShadowRootHostGetter = typeof window.ShadowRoot !== \"undefined\" ?\n    getOwnPropertyDescriptor(window.ShadowRoot.prototype, 'host').get :\n    () => {\n        throw new Error('Internal Error: Missing ShadowRoot');\n    };\nconst ShadowRootInnerHTMLSetter = typeof window.ShadowRoot !== \"undefined\" ? getOwnPropertyDescriptor(window.ShadowRoot.prototype, 'innerHTML').set : () => {\n    throw new Error('Internal Error: Missing ShadowRoot');\n};\nconst dispatchEvent = 'EventTarget' in window ?\n    EventTarget.prototype.dispatchEvent :\n    Node.prototype.dispatchEvent; // IE11\nconst isNativeShadowRootAvailable = typeof window.ShadowRoot !== \"undefined\";\nconst iFrameContentWindowGetter = getOwnPropertyDescriptor(HTMLIFrameElement.prototype, 'contentWindow').get;\nconst eventTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'target').get;\nconst eventCurrentTargetGetter = getOwnPropertyDescriptor(Event.prototype, 'currentTarget').get;\nconst focusEventRelatedTargetGetter = getOwnPropertyDescriptor(FocusEvent.prototype, 'relatedTarget').get;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst StringSplit$1 = String.prototype.split;\nfunction isLWC(element) {\n    return (element instanceof Element) && (tagNameGetter.call(element).indexOf('-') !== -1);\n}\nfunction isShadowRoot(elmOrShadow) {\n    return !(elmOrShadow instanceof Element) && ('host' in elmOrShadow);\n}\nfunction getFormattedComponentStack(elm) {\n    const componentStack = [];\n    const indentationChar = '\\t';\n    let indentation = '';\n    let currentElement = elm;\n    do {\n        if (isLWC(currentElement)) {\n            ArrayPush.call(componentStack, `${indentation}<${StringToLowerCase.call(tagNameGetter.call(currentElement))}>`);\n            indentation = indentation + indentationChar;\n        }\n        if (isShadowRoot(currentElement)) {\n            // if at some point we find a ShadowRoot, it must be a native shadow root.\n            currentElement = ShadowRootHostGetter.call(currentElement);\n        }\n        else {\n            currentElement = parentNodeGetter.call(currentElement);\n        }\n    } while (!isNull(currentElement));\n    return ArrayJoin.call(componentStack, '\\n');\n}\nconst assert = {\n    invariant(value, msg) {\n        if (!value) {\n            throw new Error(`Invariant Violation: ${msg}`);\n        }\n    },\n    isTrue(value, msg) {\n        if (!value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    },\n    isFalse(value, msg) {\n        if (value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    },\n    fail(msg) {\n        throw new Error(msg);\n    },\n    logError(message, elm) {\n        let msg = `[LWC error]: ${message}`;\n        if (elm) {\n            msg = `${msg}\\n${getFormattedComponentStack(elm)}`;\n        }\n        if (false) {}\n        try {\n            throw new Error(msg);\n        }\n        catch (e) {\n            console.error(e); // tslint:disable-line\n        }\n    },\n    logWarning(message, elm) {\n        let msg = `[LWC warning]: ${message}`;\n        if (elm) {\n            msg = `${msg}\\n${getFormattedComponentStack(elm)}`;\n        }\n        if (false) {}\n        try {\n            throw new Error('error to get stacktrace');\n        }\n        catch (e) {\n            // first line is the dummy message and second this function (which does not need to be there)\n            const stackTraceLines = StringSplit$1.call(e.stack, '\\n').splice(2);\n            console.group(msg); // tslint:disable-line\n            forEach.call(stackTraceLines, (trace) => {\n                // We need to format this as a string,\n                // because Safari will detect that the string\n                // is a stack trace line item and will format it as so\n                console.log('%s', trace.trim()); // tslint:disable-line\n            });\n            console.groupEnd(); // tslint:disable-line\n        }\n    },\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * In IE11, symbols are expensive.\n * Due to the nature of the symbol polyfill. This method abstract the\n * creation of symbols, so we can fallback to string when native symbols\n * are not supported. Note that we can't use typeof since it will fail when tranpiling.\n */\nconst hasNativeSymbolsSupport = Symbol('x').toString() === 'Symbol(x)';\nfunction createFieldName(key) {\n    // @ts-ignore: using a string as a symbol for perf reasons\n    return hasNativeSymbolsSupport ? Symbol(key) : `$$lwc-${key}$$`;\n}\nfunction setInternalField(o, fieldName, value) {\n    // TODO: improve this to use  or a WeakMap\n    defineProperty(o, fieldName, {\n        value,\n    });\n}\nfunction getInternalField(o, fieldName) {\n    return o[fieldName];\n}\n/**\n * Store fields that should be hidden from outside world\n * hiddenFieldsMap is a WeakMap.\n * It stores a hash of any given objects associative relationships.\n * The hash uses the fieldName as the key, the value represents the other end of the association.\n *\n * For example, if the association is\n *              ViewModel\n * Component-A --------------> VM-1\n * then,\n * hiddenFieldsMap : (Component-A, { Symbol(ViewModel) : VM-1 })\n *\n */\nconst hiddenFieldsMap = new WeakMap();\nconst setHiddenField = hasNativeSymbolsSupport\n    ? (o, fieldName, value) => {\n        let valuesByField = hiddenFieldsMap.get(o);\n        if (isUndefined(valuesByField)) {\n            valuesByField = create(null);\n            hiddenFieldsMap.set(o, valuesByField);\n        }\n        valuesByField[fieldName] = value;\n    }\n    : setInternalField; // Fall back to symbol based approach in compat mode\nconst getHiddenField = hasNativeSymbolsSupport\n    ? (o, fieldName) => {\n        const valuesByField = hiddenFieldsMap.get(o);\n        return !isUndefined(valuesByField) && valuesByField[fieldName];\n    }\n    : getInternalField; // Fall back to symbol based approach in compat mode\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect(propName) {\n    return Object.getOwnPropertyDescriptor(Element.prototype, propName) === undefined;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// this regular expression is used to transform aria props into aria attributes because\n// that doesn't follow the regular transformation process. e.g.: `aria-labeledby` <=> `ariaLabelBy`\nconst ARIA_REGEX = /^aria/;\nconst nodeToAriaPropertyValuesMap = new WeakMap();\nconst { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;\nconst { replace: StringReplace$1, toLowerCase: StringToLowerCase$1, } = String.prototype;\nfunction getAriaPropertyMap(elm) {\n    let map = nodeToAriaPropertyValuesMap.get(elm);\n    if (map === undefined) {\n        map = { host: {}, sr: {} };\n        nodeToAriaPropertyValuesMap.set(elm, map);\n    }\n    return map;\n}\nfunction getNormalizedAriaPropertyValue(propName, value) {\n    return value == null ? null : value + '';\n}\nfunction createAriaPropertyPropertyDescriptor(propName, attrName) {\n    return {\n        get() {\n            const map = getAriaPropertyMap(this);\n            if (hasOwnProperty$1.call(map, propName)) {\n                return map[propName];\n            }\n            // otherwise just reflect what's in the attribute\n            return hasAttribute.call(this, attrName) ? getAttribute.call(this, attrName) : null;\n        },\n        set(newValue) {\n            newValue = getNormalizedAriaPropertyValue(propName, newValue);\n            const map = getAriaPropertyMap(this);\n            map[propName] = newValue;\n            // reflect into the corresponding attribute\n            if (newValue === null) {\n                removeAttribute.call(this, attrName);\n            }\n            else {\n                setAttribute.call(this, attrName, newValue);\n            }\n        },\n        configurable: true,\n        enumerable: true,\n    };\n}\nfunction patch(propName) {\n    const attrName = StringToLowerCase$1.call(StringReplace$1.call(propName, ARIA_REGEX, 'aria-'));\n    const descriptor = createAriaPropertyPropertyDescriptor(propName, attrName);\n    Object.defineProperty(Element.prototype, propName, descriptor);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Global Aria and Role Properties derived from ARIA and Role Attributes.\n// https://wicg.github.io/aom/spec/aria-reflection.html\nconst ElementPrototypeAriaPropertyNames = [\n    'ariaAutoComplete',\n    'ariaChecked',\n    'ariaCurrent',\n    'ariaDisabled',\n    'ariaExpanded',\n    'ariaHasPopUp',\n    'ariaHidden',\n    'ariaInvalid',\n    'ariaLabel',\n    'ariaLevel',\n    'ariaMultiLine',\n    'ariaMultiSelectable',\n    'ariaOrientation',\n    'ariaPressed',\n    'ariaReadOnly',\n    'ariaRequired',\n    'ariaSelected',\n    'ariaSort',\n    'ariaValueMax',\n    'ariaValueMin',\n    'ariaValueNow',\n    'ariaValueText',\n    'ariaLive',\n    'ariaRelevant',\n    'ariaAtomic',\n    'ariaBusy',\n    'ariaActiveDescendant',\n    'ariaControls',\n    'ariaDescribedBy',\n    'ariaFlowTo',\n    'ariaLabelledBy',\n    'ariaOwns',\n    'ariaPosInSet',\n    'ariaSetSize',\n    'ariaColCount',\n    'ariaColIndex',\n    'ariaDetails',\n    'ariaErrorMessage',\n    'ariaKeyShortcuts',\n    'ariaModal',\n    'ariaPlaceholder',\n    'ariaRoleDescription',\n    'ariaRowCount',\n    'ariaRowIndex',\n    'ariaRowSpan',\n    'role',\n];\nfor (let i = 0, len = ElementPrototypeAriaPropertyNames.length; i < len; i += 1) {\n    const propName = ElementPrototypeAriaPropertyNames[i];\n    if (detect(propName)) {\n        patch(propName);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// These properties get added to LWCElement.prototype publicProps automatically\nconst defaultDefHTMLPropertyNames = ['dir', 'id', 'accessKey', 'title', 'lang', 'hidden', 'draggable', 'tabIndex'];\n// Few more exceptions that are using the attribute name to match the property in lowercase.\n// this list was compiled from https://msdn.microsoft.com/en-us/library/ms533062(v=vs.85).aspx\n// and https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n// Note: this list most be in sync with the compiler as well.\nconst HTMLPropertyNamesWithLowercasedReflectiveAttributes = [\n    'accessKey',\n    'readOnly',\n    'tabIndex',\n    'bgColor',\n    'colSpan',\n    'rowSpan',\n    'contentEditable',\n    'dateTime',\n    'formAction',\n    'isMap',\n    'maxLength',\n    'useMap',\n];\nconst OffsetPropertiesError = 'This property will round the value to an integer, and it is considered an anti-pattern. Instead, you can use \\`this.getBoundingClientRect()\\` to obtain `left`, `top`, `right`, `bottom`, `x`, `y`, `width`, and `height` fractional values describing the overall border-box in pixels.';\n// Global HTML Attributes & Properties\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes\n// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement\nfunction getGlobalHTMLPropertiesInfo() {\n    if (false) {}\n    return {\n        id: {\n            attribute: 'id',\n            reflective: true,\n        },\n        accessKey: {\n            attribute: 'accesskey',\n            reflective: true,\n        },\n        accessKeyLabel: {\n            readOnly: true,\n        },\n        className: {\n            attribute: 'class',\n            error: `Using property \"className\" is an anti-pattern because of slow runtime behavior and conflicting with classes provided by the owner element. Instead use property \"classList\".`,\n        },\n        contentEditable: {\n            attribute: 'contenteditable',\n            reflective: true,\n        },\n        isContentEditable: {\n            readOnly: true,\n        },\n        contextMenu: {\n            attribute: 'contextmenu',\n        },\n        dataset: {\n            readOnly: true,\n            error: 'Using property \"dataset\" is an anti-pattern. Components should not rely on dataset to implement its internal logic, nor use that as a communication channel.',\n        },\n        dir: {\n            attribute: 'dir',\n            reflective: true,\n        },\n        draggable: {\n            attribute: 'draggable',\n            experimental: true,\n            reflective: true,\n        },\n        dropzone: {\n            attribute: 'dropzone',\n            readOnly: true,\n            experimental: true,\n        },\n        hidden: {\n            attribute: 'hidden',\n            reflective: true,\n        },\n        itemScope: {\n            attribute: 'itemscope',\n            experimental: true,\n        },\n        itemType: {\n            attribute: 'itemtype',\n            readOnly: true,\n            experimental: true,\n        },\n        itemId: {\n            attribute: 'itemid',\n            experimental: true,\n        },\n        itemRef: {\n            attribute: 'itemref',\n            readOnly: true,\n            experimental: true,\n        },\n        itemProp: {\n            attribute: 'itemprop',\n            readOnly: true,\n            experimental: true,\n        },\n        itemValue: {\n            experimental: true,\n        },\n        lang: {\n            attribute: 'lang',\n            reflective: true,\n        },\n        offsetHeight: {\n            readOnly: true,\n            error: OffsetPropertiesError,\n        },\n        offsetLeft: {\n            readOnly: true,\n            error: OffsetPropertiesError,\n        },\n        offsetParent: {\n            readOnly: true,\n        },\n        offsetTop: {\n            readOnly: true,\n            error: OffsetPropertiesError,\n        },\n        offsetWidth: {\n            readOnly: true,\n            error: OffsetPropertiesError,\n        },\n        properties: {\n            readOnly: true,\n            experimental: true,\n        },\n        spellcheck: {\n            experimental: true,\n            reflective: true,\n        },\n        style: {\n            attribute: 'style',\n            error: `Using property or attribute \"style\" is an anti-pattern. Instead use property \"classList\".`,\n        },\n        tabIndex: {\n            attribute: 'tabindex',\n            reflective: true,\n        },\n        title: {\n            attribute: 'title',\n            reflective: true,\n        },\n        translate: {\n            experimental: true,\n        },\n        // additional global attributes that are not present in the link above.\n        role: {\n            attribute: 'role',\n        },\n        slot: {\n            attribute: 'slot',\n            experimental: true,\n            error: `Using property or attribute \"slot\" is an anti-pattern.`\n        }\n    };\n}\n// TODO: complete this list with Element properties\n// https://developer.mozilla.org/en-US/docs/Web/API/Element\n// TODO: complete this list with Node properties\n// https://developer.mozilla.org/en-US/docs/Web/API/Node\nconst AttrNameToPropNameMap = create(null);\nconst PropNameToAttrNameMap = create(null);\n// Synthetic creation of all AOM property descriptors for Custom Elements\nforEach.call(ElementPrototypeAriaPropertyNames, (propName) => {\n    const attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, 'aria-'));\n    AttrNameToPropNameMap[attrName] = propName;\n    PropNameToAttrNameMap[propName] = attrName;\n});\nforEach.call(defaultDefHTMLPropertyNames, (propName) => {\n    const attrName = StringToLowerCase.call(propName);\n    AttrNameToPropNameMap[attrName] = propName;\n    PropNameToAttrNameMap[propName] = attrName;\n});\nforEach.call(HTMLPropertyNamesWithLowercasedReflectiveAttributes, (propName) => {\n    const attrName = StringToLowerCase.call(propName);\n    AttrNameToPropNameMap[attrName] = propName;\n    PropNameToAttrNameMap[propName] = attrName;\n});\nconst CAMEL_REGEX = /-([a-z])/g;\n/**\n * This method maps between attribute names\n * and the corresponding property name.\n */\nfunction getPropNameFromAttrName(attrName) {\n    if (isUndefined(AttrNameToPropNameMap[attrName])) {\n        AttrNameToPropNameMap[attrName] = StringReplace.call(attrName, CAMEL_REGEX, (g) => g[1].toUpperCase());\n    }\n    return AttrNameToPropNameMap[attrName];\n}\nconst CAPS_REGEX = /[A-Z]/g;\n/**\n * This method maps between property names\n * and the corresponding attribute name.\n */\nfunction getAttrNameFromPropName(propName) {\n    if (isUndefined(PropNameToAttrNameMap[propName])) {\n        PropNameToAttrNameMap[propName] = StringReplace.call(propName, CAPS_REGEX, (match) => '-' + match.toLowerCase());\n    }\n    return PropNameToAttrNameMap[propName];\n}\nlet controlledElement = null;\nlet controlledAttributeName;\nfunction isAttributeLocked(elm, attrName) {\n    return elm !== controlledElement || attrName !== controlledAttributeName;\n}\nfunction lockAttribute(elm, key) {\n    controlledElement = null;\n    controlledAttributeName = undefined;\n}\nfunction unlockAttribute(elm, key) {\n    controlledElement = elm;\n    controlledAttributeName = key;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet nextTickCallbackQueue = [];\nconst SPACE_CHAR = 32;\nconst EmptyObject = seal(create(null));\nconst EmptyArray = seal([]);\nconst ViewModelReflection = createFieldName('ViewModel');\nfunction flushCallbackQueue() {\n    if (true) {\n        if (nextTickCallbackQueue.length === 0) {\n            throw new Error(`Internal Error: If callbackQueue is scheduled, it is because there must be at least one callback on this pending queue.`);\n        }\n    }\n    const callbacks = nextTickCallbackQueue;\n    nextTickCallbackQueue = []; // reset to a new queue\n    for (let i = 0, len = callbacks.length; i < len; i += 1) {\n        callbacks[i]();\n    }\n}\nfunction addCallbackToNextTick(callback) {\n    if (true) {\n        if (!isFunction(callback)) {\n            throw new Error(`Internal Error: addCallbackToNextTick() can only accept a function callback`);\n        }\n    }\n    if (nextTickCallbackQueue.length === 0) {\n        Promise.resolve().then(flushCallbackQueue);\n    }\n    // TODO: eventually, we might want to have priority when inserting callbacks\n    ArrayPush.call(nextTickCallbackQueue, callback);\n}\nfunction isCircularModuleDependency(value) {\n    return hasOwnProperty.call(value, '__circular__');\n}\n/**\n * When LWC is used in the context of an Aura application, the compiler produces AMD\n * modules, that doesn't resolve properly circular dependencies between modules. In order\n * to circumvent this issue, the module loader returns a factory with a symbol attached\n * to it.\n *\n * This method returns the resolved value if it received a factory as argument. Otherwise\n * it returns the original value.\n */\nfunction resolveCircularModuleDependency(fn) {\n    if (true) {\n        if (!isFunction(fn)) {\n            throw new ReferenceError(`Circular module dependency must be a function.`);\n        }\n    }\n    return fn();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction handleEvent(event, vnode) {\n    const { type } = event;\n    const { data: { on } } = vnode;\n    const handler = on && on[type];\n    // call event handler if exists\n    if (handler) {\n        handler.call(undefined, event);\n    }\n}\nfunction createListener() {\n    return function handler(event) {\n        handleEvent(event, handler.vnode);\n    };\n}\nfunction updateAllEventListeners(oldVnode, vnode) {\n    if (isUndefined(oldVnode.listener)) {\n        createAllEventListeners(vnode);\n    }\n    else {\n        vnode.listener = oldVnode.listener;\n        vnode.listener.vnode = vnode;\n    }\n}\nfunction createAllEventListeners(vnode) {\n    const { data: { on } } = vnode;\n    if (isUndefined(on)) {\n        return;\n    }\n    const elm = vnode.elm;\n    const listener = vnode.listener = createListener();\n    listener.vnode = vnode;\n    let name;\n    for (name in on) {\n        elm.addEventListener(name, listener);\n    }\n}\nvar modEvents = {\n    update: updateAllEventListeners,\n    create: createAllEventListeners,\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nconst xmlNS = 'http://www.w3.org/XML/1998/namespace';\nconst ColonCharCode = 58;\nfunction updateAttrs(oldVnode, vnode) {\n    const { data: { attrs } } = vnode;\n    if (isUndefined(attrs)) {\n        return;\n    }\n    let { data: { attrs: oldAttrs } } = oldVnode;\n    if (oldAttrs === attrs) {\n        return;\n    }\n    if (true) {\n        assert.invariant(isUndefined(oldAttrs) || keys(oldAttrs).join(',') === keys(attrs).join(','), `vnode.data.attrs cannot change shape.`);\n    }\n    const elm = vnode.elm;\n    let key;\n    oldAttrs = isUndefined(oldAttrs) ? EmptyObject : oldAttrs;\n    // update modified attributes, add new attributes\n    // this routine is only useful for data-* attributes in all kind of elements\n    // and aria-* in standard elements (custom elements will use props for these)\n    for (key in attrs) {\n        const cur = attrs[key];\n        const old = oldAttrs[key];\n        if (old !== cur) {\n            unlockAttribute(elm, key);\n            if (StringCharCodeAt.call(key, 3) === ColonCharCode) {\n                // Assume xml namespace\n                elm.setAttributeNS(xmlNS, key, cur);\n            }\n            else if (StringCharCodeAt.call(key, 5) === ColonCharCode) {\n                // Assume xlink namespace\n                elm.setAttributeNS(xlinkNS, key, cur);\n            }\n            else if (isNull(cur)) {\n                elm.removeAttribute(key);\n            }\n            else {\n                elm.setAttribute(key, cur);\n            }\n            lockAttribute(elm, key);\n        }\n    }\n}\nconst emptyVNode = { data: {} };\nvar modAttrs = {\n    create: (vnode) => updateAttrs(emptyVNode, vnode),\n    update: updateAttrs\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst TargetToReactiveRecordMap = new WeakMap();\nfunction notifyMutation(target, key) {\n    if (true) {\n        assert.invariant(!isRendering, `Mutating property ${toString(key)} of ${toString(target)} is not allowed during the rendering life-cycle of ${vmBeingRendered}.`);\n    }\n    const reactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (!isUndefined(reactiveRecord)) {\n        const value = reactiveRecord[key];\n        if (value) {\n            const len = value.length;\n            for (let i = 0; i < len; i += 1) {\n                const vm = value[i];\n                if (true) {\n                    assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n                }\n                if (!vm.isDirty) {\n                    markComponentAsDirty(vm);\n                    scheduleRehydration(vm);\n                }\n            }\n        }\n    }\n}\nfunction observeMutation(target, key) {\n    if (isNull(vmBeingRendered)) {\n        return; // nothing to subscribe to\n    }\n    const vm = vmBeingRendered;\n    let reactiveRecord = TargetToReactiveRecordMap.get(target);\n    if (isUndefined(reactiveRecord)) {\n        const newRecord = create(null);\n        reactiveRecord = newRecord;\n        TargetToReactiveRecordMap.set(target, newRecord);\n    }\n    let value = reactiveRecord[key];\n    if (isUndefined(value)) {\n        value = [];\n        reactiveRecord[key] = value;\n    }\n    else if (value[0] === vm) {\n        return; // perf optimization considering that most subscriptions will come from the same vm\n    }\n    if (ArrayIndexOf.call(value, vm) === -1) {\n        ArrayPush.call(value, vm);\n        // we keep track of the sets that vm is listening from to be able to do some clean up later on\n        ArrayPush.call(vm.deps, value);\n    }\n}\n\n/**\n * Copyright (C) 2017 salesforce.com, inc.\n */\nconst { isArray: isArray$1 } = Array;\nconst { getPrototypeOf: getPrototypeOf$1, create: ObjectCreate, defineProperty: ObjectDefineProperty, defineProperties: ObjectDefineProperties, isExtensible: isExtensible$1, getOwnPropertyDescriptor: getOwnPropertyDescriptor$1, getOwnPropertyNames: getOwnPropertyNames$1, getOwnPropertySymbols: getOwnPropertySymbols$1, preventExtensions: preventExtensions$1, } = Object;\nconst { push: ArrayPush$1, concat: ArrayConcat$1, map: ArrayMap$1, } = Array.prototype;\nconst ObjectDotPrototype = Object.prototype;\nconst OtS$1 = {}.toString;\nfunction toString$1(obj) {\n    if (obj && obj.toString) {\n        return obj.toString();\n    }\n    else if (typeof obj === 'object') {\n        return OtS$1.call(obj);\n    }\n    else {\n        return obj + '';\n    }\n}\nfunction isUndefined$1(obj) {\n    return obj === undefined;\n}\nconst TargetSlot = Symbol();\n// TODO: we are using a funky and leaky abstraction here to try to identify if\n// the proxy is a compat proxy, and define the unwrap method accordingly.\n// @ts-ignore\nconst { getKey } = Proxy;\nconst unwrap = getKey ?\n    (replicaOrAny) => (replicaOrAny && getKey(replicaOrAny, TargetSlot)) || replicaOrAny\n    : (replicaOrAny) => (replicaOrAny && replicaOrAny[TargetSlot]) || replicaOrAny;\nfunction isObservable(value) {\n    // intentionally checking for null and undefined\n    if (value == null) {\n        return false;\n    }\n    if (isArray$1(value)) {\n        return true;\n    }\n    const proto = getPrototypeOf$1(value);\n    return (proto === ObjectDotPrototype || proto === null || getPrototypeOf$1(proto) === null);\n}\nfunction isObject$1(obj) {\n    return typeof obj === 'object';\n}\n// Unwrap property descriptors\n// We only need to unwrap if value is specified\nfunction unwrapDescriptor(descriptor) {\n    if ('value' in descriptor) {\n        descriptor.value = unwrap(descriptor.value);\n    }\n    return descriptor;\n}\nfunction wrapDescriptor(membrane, descriptor) {\n    if ('value' in descriptor) {\n        descriptor.value = isObservable(descriptor.value) ? membrane.getProxy(descriptor.value) : descriptor.value;\n    }\n    return descriptor;\n}\nfunction lockShadowTarget(membrane, shadowTarget, originalTarget) {\n    const targetKeys = ArrayConcat$1.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols$1(originalTarget));\n    targetKeys.forEach((key) => {\n        let descriptor = getOwnPropertyDescriptor$1(originalTarget, key);\n        // We do not need to wrap the descriptor if not configurable\n        // Because we can deal with wrapping it when user goes through\n        // Get own property descriptor. There is also a chance that this descriptor\n        // could change sometime in the future, so we can defer wrapping\n        // until we need to\n        if (!descriptor.configurable) {\n            descriptor = wrapDescriptor(membrane, descriptor);\n        }\n        ObjectDefineProperty(shadowTarget, key, descriptor);\n    });\n    preventExtensions$1(shadowTarget);\n}\nclass ReactiveProxyHandler {\n    constructor(membrane, value, options) {\n        this.originalTarget = value;\n        this.membrane = membrane;\n        if (!isUndefined$1(options)) {\n            this.valueMutated = options.valueMutated;\n            this.valueObserved = options.valueObserved;\n        }\n    }\n    get(shadowTarget, key) {\n        const { originalTarget, membrane } = this;\n        if (key === TargetSlot) {\n            return originalTarget;\n        }\n        const value = originalTarget[key];\n        const { valueObserved } = this;\n        if (!isUndefined$1(valueObserved)) {\n            valueObserved(originalTarget, key);\n        }\n        return membrane.getProxy(value);\n    }\n    set(shadowTarget, key, value) {\n        const { originalTarget, valueMutated } = this;\n        const oldValue = originalTarget[key];\n        if (oldValue !== value) {\n            originalTarget[key] = value;\n            if (!isUndefined$1(valueMutated)) {\n                valueMutated(originalTarget, key);\n            }\n        }\n        else if (key === 'length' && isArray$1(originalTarget)) {\n            // fix for issue #236: push will add the new index, and by the time length\n            // is updated, the internal length is already equal to the new length value\n            // therefore, the oldValue is equal to the value. This is the forking logic\n            // to support this use case.\n            if (!isUndefined$1(valueMutated)) {\n                valueMutated(originalTarget, key);\n            }\n        }\n        return true;\n    }\n    deleteProperty(shadowTarget, key) {\n        const { originalTarget, valueMutated } = this;\n        delete originalTarget[key];\n        if (!isUndefined$1(valueMutated)) {\n            valueMutated(originalTarget, key);\n        }\n        return true;\n    }\n    apply(shadowTarget, thisArg, argArray) {\n        /* No op */\n    }\n    construct(target, argArray, newTarget) {\n        /* No op */\n    }\n    has(shadowTarget, key) {\n        const { originalTarget, valueObserved } = this;\n        if (!isUndefined$1(valueObserved)) {\n            valueObserved(originalTarget, key);\n        }\n        return key in originalTarget;\n    }\n    ownKeys(shadowTarget) {\n        const { originalTarget } = this;\n        return ArrayConcat$1.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols$1(originalTarget));\n    }\n    isExtensible(shadowTarget) {\n        const shadowIsExtensible = isExtensible$1(shadowTarget);\n        if (!shadowIsExtensible) {\n            return shadowIsExtensible;\n        }\n        const { originalTarget, membrane } = this;\n        const targetIsExtensible = isExtensible$1(originalTarget);\n        if (!targetIsExtensible) {\n            lockShadowTarget(membrane, shadowTarget, originalTarget);\n        }\n        return targetIsExtensible;\n    }\n    setPrototypeOf(shadowTarget, prototype) {\n        if (true) {\n            throw new Error(`Invalid setPrototypeOf invocation for reactive proxy ${toString$1(this.originalTarget)}. Prototype of reactive objects cannot be changed.`);\n        }\n    }\n    getPrototypeOf(shadowTarget) {\n        const { originalTarget } = this;\n        return getPrototypeOf$1(originalTarget);\n    }\n    getOwnPropertyDescriptor(shadowTarget, key) {\n        const { originalTarget, membrane, valueObserved } = this;\n        // keys looked up via hasOwnProperty need to be reactive\n        if (!isUndefined$1(valueObserved)) {\n            valueObserved(originalTarget, key);\n        }\n        let desc = getOwnPropertyDescriptor$1(originalTarget, key);\n        if (isUndefined$1(desc)) {\n            return desc;\n        }\n        const shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);\n        if (!desc.configurable && !shadowDescriptor) {\n            // If descriptor from original target is not configurable,\n            // We must copy the wrapped descriptor over to the shadow target.\n            // Otherwise, proxy will throw an invariant error.\n            // This is our last chance to lock the value.\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n            desc = wrapDescriptor(membrane, desc);\n            ObjectDefineProperty(shadowTarget, key, desc);\n        }\n        return shadowDescriptor || desc;\n    }\n    preventExtensions(shadowTarget) {\n        const { originalTarget, membrane } = this;\n        lockShadowTarget(membrane, shadowTarget, originalTarget);\n        preventExtensions$1(originalTarget);\n        return true;\n    }\n    defineProperty(shadowTarget, key, descriptor) {\n        const { originalTarget, membrane, valueMutated } = this;\n        const { configurable } = descriptor;\n        // We have to check for value in descriptor\n        // because Object.freeze(proxy) calls this method\n        // with only { configurable: false, writeable: false }\n        // Additionally, method will only be called with writeable:false\n        // if the descriptor has a value, as opposed to getter/setter\n        // So we can just check if writable is present and then see if\n        // value is present. This eliminates getter and setter descriptors\n        if ('writable' in descriptor && !('value' in descriptor)) {\n            const originalDescriptor = getOwnPropertyDescriptor$1(originalTarget, key);\n            descriptor.value = originalDescriptor.value;\n        }\n        ObjectDefineProperty(originalTarget, key, unwrapDescriptor(descriptor));\n        if (configurable === false) {\n            ObjectDefineProperty(shadowTarget, key, wrapDescriptor(membrane, descriptor));\n        }\n        if (!isUndefined$1(valueMutated)) {\n            valueMutated(originalTarget, key);\n        }\n        return true;\n    }\n}\nfunction wrapDescriptor$1(membrane, descriptor) {\n    if ('value' in descriptor) {\n        descriptor.value = isObservable(descriptor.value) ? membrane.getReadOnlyProxy(descriptor.value) : descriptor.value;\n    }\n    return descriptor;\n}\nclass ReadOnlyHandler {\n    constructor(membrane, value, options) {\n        this.originalTarget = value;\n        this.membrane = membrane;\n        if (!isUndefined$1(options)) {\n            this.valueObserved = options.valueObserved;\n        }\n    }\n    get(shadowTarget, key) {\n        const { membrane, originalTarget } = this;\n        if (key === TargetSlot) {\n            return originalTarget;\n        }\n        const value = originalTarget[key];\n        const { valueObserved } = this;\n        if (!isUndefined$1(valueObserved)) {\n            valueObserved(originalTarget, key);\n        }\n        return membrane.getReadOnlyProxy(value);\n    }\n    set(shadowTarget, key, value) {\n        if (true) {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot set \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n        }\n        return false;\n    }\n    deleteProperty(shadowTarget, key) {\n        if (true) {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot delete \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n        }\n        return false;\n    }\n    apply(shadowTarget, thisArg, argArray) {\n        /* No op */\n    }\n    construct(target, argArray, newTarget) {\n        /* No op */\n    }\n    has(shadowTarget, key) {\n        const { originalTarget } = this;\n        const { valueObserved } = this;\n        if (!isUndefined$1(valueObserved)) {\n            valueObserved(originalTarget, key);\n        }\n        return key in originalTarget;\n    }\n    ownKeys(shadowTarget) {\n        const { originalTarget } = this;\n        return ArrayConcat$1.call(getOwnPropertyNames$1(originalTarget), getOwnPropertySymbols$1(originalTarget));\n    }\n    setPrototypeOf(shadowTarget, prototype) {\n        if (true) {\n            const { originalTarget } = this;\n            throw new Error(`Invalid prototype mutation: Cannot set prototype on \"${originalTarget}\". \"${originalTarget}\" prototype is read-only.`);\n        }\n    }\n    getOwnPropertyDescriptor(shadowTarget, key) {\n        const { originalTarget, membrane, valueObserved } = this;\n        // keys looked up via hasOwnProperty need to be reactive\n        if (!isUndefined$1(valueObserved)) {\n            valueObserved(originalTarget, key);\n        }\n        let desc = getOwnPropertyDescriptor$1(originalTarget, key);\n        if (isUndefined$1(desc)) {\n            return desc;\n        }\n        const shadowDescriptor = getOwnPropertyDescriptor$1(shadowTarget, key);\n        if (!desc.configurable && !shadowDescriptor) {\n            // If descriptor from original target is not configurable,\n            // We must copy the wrapped descriptor over to the shadow target.\n            // Otherwise, proxy will throw an invariant error.\n            // This is our last chance to lock the value.\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor#Invariants\n            desc = wrapDescriptor$1(membrane, desc);\n            ObjectDefineProperty(shadowTarget, key, desc);\n        }\n        return shadowDescriptor || desc;\n    }\n    preventExtensions(shadowTarget) {\n        if (true) {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot preventExtensions on ${originalTarget}\". \"${originalTarget} is read-only.`);\n        }\n        return false;\n    }\n    defineProperty(shadowTarget, key, descriptor) {\n        if (true) {\n            const { originalTarget } = this;\n            throw new Error(`Invalid mutation: Cannot defineProperty \"${key.toString()}\" on \"${originalTarget}\". \"${originalTarget}\" is read-only.`);\n        }\n        return false;\n    }\n}\nfunction getTarget(item) {\n    return item && item[TargetSlot];\n}\nfunction extract(objectOrArray) {\n    if (isArray$1(objectOrArray)) {\n        return objectOrArray.map((item) => {\n            const original = getTarget(item);\n            if (original) {\n                return extract(original);\n            }\n            return item;\n        });\n    }\n    const obj = ObjectCreate(getPrototypeOf$1(objectOrArray));\n    const names = getOwnPropertyNames$1(objectOrArray);\n    return ArrayConcat$1.call(names, getOwnPropertySymbols$1(objectOrArray))\n        .reduce((seed, key) => {\n        const item = objectOrArray[key];\n        const original = getTarget(item);\n        if (original) {\n            seed[key] = extract(original);\n        }\n        else {\n            seed[key] = item;\n        }\n        return seed;\n    }, obj);\n}\nconst formatter = {\n    header: (plainOrProxy) => {\n        const originalTarget = plainOrProxy[TargetSlot];\n        if (!originalTarget) {\n            return null;\n        }\n        const obj = extract(plainOrProxy);\n        return ['object', { object: obj }];\n    },\n    hasBody: () => {\n        return false;\n    },\n    body: () => {\n        return null;\n    }\n};\nfunction init() {\n    if (false) {}\n    // Custom Formatter for Dev Tools\n    // To enable this, open Chrome Dev Tools\n    // Go to Settings,\n    // Under console, select \"Enable custom formatters\"\n    // For more information, https://docs.google.com/document/d/1FTascZXT9cxfetuPRT2eXPQKXui4nWFivUnS_335T3U/preview\n    const devWindow = window;\n    const devtoolsFormatters = devWindow.devtoolsFormatters || [];\n    ArrayPush$1.call(devtoolsFormatters, formatter);\n    devWindow.devtoolsFormatters = devtoolsFormatters;\n}\nif (true) {\n    init();\n}\nfunction createShadowTarget(value) {\n    let shadowTarget = undefined;\n    if (isArray$1(value)) {\n        shadowTarget = [];\n    }\n    else if (isObject$1(value)) {\n        shadowTarget = {};\n    }\n    return shadowTarget;\n}\nclass ReactiveMembrane {\n    constructor(options) {\n        this.objectGraph = new WeakMap();\n        if (!isUndefined$1(options)) {\n            this.valueDistortion = options.valueDistortion;\n            this.valueMutated = options.valueMutated;\n            this.valueObserved = options.valueObserved;\n        }\n    }\n    getProxy(value) {\n        const { valueDistortion } = this;\n        const distorted = isUndefined$1(valueDistortion) ? value : valueDistortion(value);\n        if (isObservable(distorted)) {\n            const o = this.getReactiveState(distorted);\n            // when trying to extract the writable version of a readonly\n            // we return the readonly.\n            return o.readOnly === value ? value : o.reactive;\n        }\n        return distorted;\n    }\n    getReadOnlyProxy(value) {\n        const { valueDistortion } = this;\n        const distorted = isUndefined$1(valueDistortion) ? value : valueDistortion(value);\n        if (isObservable(distorted)) {\n            return this.getReactiveState(distorted).readOnly;\n        }\n        return distorted;\n    }\n    unwrapProxy(p) {\n        return unwrap(p);\n    }\n    getReactiveState(value) {\n        const membrane = this;\n        const { objectGraph, valueMutated, valueObserved, } = membrane;\n        value = unwrap(value);\n        let reactiveState = objectGraph.get(value);\n        if (reactiveState) {\n            return reactiveState;\n        }\n        reactiveState = ObjectDefineProperties(ObjectCreate(null), {\n            reactive: {\n                get() {\n                    const reactiveHandler = new ReactiveProxyHandler(membrane, value, {\n                        valueMutated,\n                        valueObserved,\n                    });\n                    // caching the reactive proxy after the first time it is accessed\n                    const proxy = new Proxy(createShadowTarget(value), reactiveHandler);\n                    ObjectDefineProperty(this, 'reactive', { value: proxy });\n                    return proxy;\n                },\n                configurable: true,\n            },\n            readOnly: {\n                get() {\n                    const readOnlyHandler = new ReadOnlyHandler(membrane, value, {\n                        valueObserved,\n                    });\n                    // caching the readOnly proxy after the first time it is accessed\n                    const proxy = new Proxy(createShadowTarget(value), readOnlyHandler);\n                    ObjectDefineProperty(this, 'readOnly', { value: proxy });\n                    return proxy;\n                },\n                configurable: true,\n            }\n        });\n        objectGraph.set(value, reactiveState);\n        return reactiveState;\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction valueDistortion(value) {\n    return value;\n}\nconst reactiveMembrane = new ReactiveMembrane({\n    valueObserved: observeMutation,\n    valueMutated: notifyMutation,\n    valueDistortion,\n});\n// TODO: REMOVE THIS https://github.com/salesforce/lwc/issues/129\nfunction dangerousObjectMutation(obj) {\n    if (true) {\n        assert.logWarning(`Dangerously Mutating Object ${toString(obj)}. This object was passed to you from a parent component, and should not be mutated here. This will be removed in the near future.`);\n    }\n    return reactiveMembrane.getProxy(unwrap$1(obj));\n}\n// Universal unwrap mechanism that works for observable membrane\n// and wrapped iframe contentWindow\nconst unwrap$1 = function (value) {\n    const unwrapped = reactiveMembrane.unwrapProxy(value);\n    if (unwrapped !== value) {\n        return unwrapped;\n    }\n    return value;\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction track(target, prop, descriptor) {\n    if (arguments.length === 1) {\n        return reactiveMembrane.getProxy(target);\n    }\n    if (true) {\n        if (arguments.length !== 3) {\n            assert.fail(`@track decorator can only be used with one argument to return a trackable object, or as a decorator function.`);\n        }\n        if (!isUndefined(descriptor)) {\n            const { get, set, configurable, writable } = descriptor;\n            assert.isTrue(!get && !set, `Compiler Error: A @track decorator can only be applied to a public field.`);\n            assert.isTrue(configurable !== false, `Compiler Error: A @track decorator can only be applied to a configurable property.`);\n            assert.isTrue(writable !== false, `Compiler Error: A @track decorator can only be applied to a writable property.`);\n        }\n    }\n    return createTrackedPropertyDescriptor(target, prop, isUndefined(descriptor) ? true : descriptor.enumerable === true);\n}\nfunction createTrackedPropertyDescriptor(Ctor, key, enumerable) {\n    return {\n        get() {\n            const vm = getComponentVM(this);\n            if (true) {\n                assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n            }\n            observeMutation(this, key);\n            return vm.cmpTrack[key];\n        },\n        set(newValue) {\n            const vm = getComponentVM(this);\n            if (true) {\n                assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n                assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${String(key)}`);\n            }\n            const reactiveOrAnyValue = reactiveMembrane.getProxy(newValue);\n            if (reactiveOrAnyValue !== vm.cmpTrack[key]) {\n                if (true) {\n                    // reactiveMembrane.getProxy(newValue) will return a different value (proxy)\n                    // Then newValue if newValue is observable (plain object or array)\n                    const isObservable = reactiveOrAnyValue !== newValue;\n                    if (!isObservable && newValue !== null && (isObject(newValue) || isArray(newValue))) {\n                        assert.logWarning(`Property \"${toString(key)}\" of ${vm} is set to a non-trackable object, which means changes into that object cannot be observed.`, vm.elm);\n                    }\n                }\n                vm.cmpTrack[key] = reactiveOrAnyValue;\n                if (vm.idx > 0) {\n                    // perf optimization to skip this step if not in the DOM\n                    notifyMutation(this, key);\n                }\n            }\n        },\n        enumerable,\n        configurable: true,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction wireDecorator(target, prop, descriptor) {\n    if (true) {\n        if (!isUndefined(descriptor)) {\n            const { get, set, configurable, writable } = descriptor;\n            assert.isTrue(!get && !set, `Compiler Error: A @wire decorator can only be applied to a public field.`);\n            assert.isTrue(configurable !== false, `Compiler Error: A @wire decorator can only be applied to a configurable property.`);\n            assert.isTrue(writable !== false, `Compiler Error: A @wire decorator can only be applied to a writable property.`);\n        }\n    }\n    // TODO: eventually this decorator should have its own logic\n    return createTrackedPropertyDescriptor(target, prop, isObject(descriptor) ? descriptor.enumerable === true : true);\n}\n// @wire is a factory that when invoked, returns the wire decorator\nfunction wire(adapter, config) {\n    const len = arguments.length;\n    if (len > 0 && len < 3) {\n        return wireDecorator;\n    }\n    else {\n        if (true) {\n            assert.fail(\"@wire(adapter, config?) may only be used as a decorator.\");\n        }\n        throw new TypeError();\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction decorate(Ctor, decorators) {\n    // intentionally comparing decorators with null and undefined\n    if (!isFunction(Ctor) || decorators == null) {\n        throw new TypeError();\n    }\n    const props = getOwnPropertyNames(decorators);\n    // intentionally allowing decoration of classes only for now\n    const target = Ctor.prototype;\n    for (let i = 0, len = props.length; i < len; i += 1) {\n        const propName = props[i];\n        const decorator = decorators[propName];\n        if (!isFunction(decorator)) {\n            throw new TypeError();\n        }\n        const originalDescriptor = getOwnPropertyDescriptor(target, propName);\n        const descriptor = decorator(Ctor, propName, originalDescriptor);\n        if (!isUndefined(descriptor)) {\n            defineProperty(target, propName, descriptor);\n        }\n    }\n    return Ctor; // chaining\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst signedDecoratorToMetaMap = new Map();\nfunction registerDecorators(Ctor, meta) {\n    const decoratorMap = create(null);\n    const props = getPublicPropertiesHash(Ctor, meta.publicProps);\n    const methods = getPublicMethodsHash(Ctor, meta.publicMethods);\n    const wire$$1 = getWireHash(Ctor, meta.wire);\n    const track$$1 = getTrackHash(Ctor, meta.track);\n    signedDecoratorToMetaMap.set(Ctor, {\n        props,\n        methods,\n        wire: wire$$1,\n        track: track$$1,\n    });\n    for (const propName in props) {\n        decoratorMap[propName] = api;\n    }\n    if (wire$$1) {\n        for (const propName in wire$$1) {\n            const wireDef = wire$$1[propName];\n            if (wireDef.method) {\n                // for decorated methods we need to do nothing\n                continue;\n            }\n            decoratorMap[propName] = wire(wireDef.adapter, wireDef.params);\n        }\n    }\n    if (track$$1) {\n        for (const propName in track$$1) {\n            decoratorMap[propName] = track;\n        }\n    }\n    decorate(Ctor, decoratorMap);\n    return Ctor;\n}\nfunction getDecoratorsRegisteredMeta(Ctor) {\n    return signedDecoratorToMetaMap.get(Ctor);\n}\nfunction getTrackHash(target, track$$1) {\n    if (isUndefined(track$$1) || getOwnPropertyNames(track$$1).length === 0) {\n        return EmptyObject;\n    }\n    // TODO: check that anything in `track` is correctly defined in the prototype\n    return assign(create(null), track$$1);\n}\nfunction getWireHash(target, wire$$1) {\n    if (isUndefined(wire$$1) || getOwnPropertyNames(wire$$1).length === 0) {\n        return;\n    }\n    // TODO: check that anything in `wire` is correctly defined in the prototype\n    return assign(create(null), wire$$1);\n}\nfunction getPublicPropertiesHash(target, props) {\n    if (isUndefined(props) || getOwnPropertyNames(props).length === 0) {\n        return EmptyObject;\n    }\n    return getOwnPropertyNames(props).reduce((propsHash, propName) => {\n        const attrName = getAttrNameFromPropName(propName);\n        if (true) {\n            const globalHTMLProperty = getGlobalHTMLPropertiesInfo()[propName];\n            if (globalHTMLProperty && globalHTMLProperty.attribute && globalHTMLProperty.reflective === false) {\n                const { error, attribute, experimental } = globalHTMLProperty;\n                const msg = [];\n                if (error) {\n                    msg.push(error);\n                }\n                else if (experimental) {\n                    msg.push(`\"${propName}\" is an experimental property that is not standardized or supported by all browsers. You should not use \"${propName}\" and attribute \"${attribute}\" in your component.`);\n                }\n                else {\n                    msg.push(`\"${propName}\" is a global HTML property. Instead access it via the reflective attribute \"${attribute}\" with one of these techniques:`);\n                    msg.push(`  * Use \\`this.getAttribute(\"${attribute}\")\\` to access the attribute value. This option is best suited for accessing the value in a getter during the rendering process.`);\n                }\n                assert.logError(msg.join('\\n'));\n            }\n        }\n        propsHash[propName] = assign({\n            config: 0,\n            type: 'any',\n            attr: attrName,\n        }, props[propName]);\n        return propsHash;\n    }, create(null));\n}\nfunction getPublicMethodsHash(target, publicMethods) {\n    if (isUndefined(publicMethods) || publicMethods.length === 0) {\n        return EmptyObject;\n    }\n    return publicMethods.reduce((methodsHash, methodName) => {\n        if (true) {\n            assert.isTrue(isFunction(target.prototype[methodName]), `Component \"${target.name}\" should have a method \\`${methodName}\\` instead of ${target.prototype[methodName]}.`);\n        }\n        methodsHash[methodName] = target.prototype[methodName];\n        return methodsHash;\n    }, create(null));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction api(target, propName, descriptor) {\n    if (true) {\n        if (arguments.length !== 3) {\n            assert.fail(`@api decorator can only be used as a decorator function.`);\n        }\n    }\n    if (true) {\n        assert.invariant(!descriptor || (isFunction(descriptor.get) || isFunction(descriptor.set)), `Invalid property ${toString(propName)} definition in ${target}, it cannot be a prototype definition if it is a public property. Instead use the constructor to define it.`);\n        if (isObject(descriptor) && isFunction(descriptor.set)) {\n            assert.isTrue(isObject(descriptor) && isFunction(descriptor.get), `Missing getter for property ${toString(propName)} decorated with @api in ${target}. You cannot have a setter without the corresponding getter.`);\n        }\n    }\n    const meta = getDecoratorsRegisteredMeta(target);\n    // initializing getters and setters for each public prop on the target prototype\n    if (isObject(descriptor) && (isFunction(descriptor.get) || isFunction(descriptor.set))) {\n        // if it is configured as an accessor it must have a descriptor\n        // @ts-ignore it must always be set before calling this method\n        meta.props[propName].config = isFunction(descriptor.set) ? 3 : 1;\n        return createPublicAccessorDescriptor(target, propName, descriptor);\n    }\n    else {\n        // @ts-ignore it must always be set before calling this method\n        meta.props[propName].config = 0;\n        return createPublicPropertyDescriptor(target, propName, descriptor);\n    }\n}\nlet vmBeingUpdated = null;\nfunction prepareForPropUpdate(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    vmBeingUpdated = vm;\n}\nfunction createPublicPropertyDescriptor(proto, key, descriptor) {\n    return {\n        get() {\n            const vm = getComponentVM(this);\n            if (true) {\n                assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n            }\n            if (isBeingConstructed(vm)) {\n                if (true) {\n                    assert.logError(`${vm} constructor should not read the value of property \"${toString(key)}\". The owner component has not yet set the value. Instead use the constructor to set default values for properties.`, vm.elm);\n                }\n                return;\n            }\n            observeMutation(this, key);\n            return vm.cmpProps[key];\n        },\n        set(newValue) {\n            const vm = getComponentVM(this);\n            if (true) {\n                assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n                assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString(key)}`);\n            }\n            if (isTrue(vm.isRoot) || isBeingConstructed(vm)) {\n                vmBeingUpdated = vm;\n                if (true) {\n                    // reactiveMembrane.getProxy(newValue) will return a different value (proxy)\n                    // Then newValue if newValue is observable (plain object or array)\n                    const isObservable = reactiveMembrane.getProxy(newValue) !== newValue;\n                    if (!isObservable && !isNull(newValue) && isObject(newValue)) {\n                        assert.logWarning(`Assigning a non-reactive value ${newValue} to member property ${toString(key)} of ${vm} is not common because mutations on that value cannot be observed.`, vm.elm);\n                    }\n                }\n            }\n            if (true) {\n                if (vmBeingUpdated !== vm) {\n                    // logic for setting new properties of the element directly from the DOM\n                    // is only recommended for root elements created via createElement()\n                    assert.logWarning(`If property ${toString(key)} decorated with @api in ${vm} is used in the template, the value ${toString(newValue)} set manually may be overridden by the template, consider binding the property only in the template.`, vm.elm);\n                }\n            }\n            vmBeingUpdated = null; // releasing the lock\n            // not need to wrap or check the value since that is happening somewhere else\n            vm.cmpProps[key] = reactiveMembrane.getReadOnlyProxy(newValue);\n            // avoid notification of observability while constructing the instance\n            if (vm.idx > 0) {\n                // perf optimization to skip this step if not in the DOM\n                notifyMutation(this, key);\n            }\n        },\n        enumerable: isUndefined(descriptor) ? true : descriptor.enumerable,\n    };\n}\nfunction createPublicAccessorDescriptor(Ctor, key, descriptor) {\n    const { get, set, enumerable } = descriptor;\n    if (!isFunction(get)) {\n        if (true) {\n            assert.fail(`Invalid attempt to create public property descriptor ${toString(key)} in ${Ctor}. It is missing the getter declaration with @api get ${toString(key)}() {} syntax.`);\n        }\n        throw new TypeError();\n    }\n    return {\n        get() {\n            if (true) {\n                const vm = getComponentVM(this);\n                assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n            }\n            return get.call(this);\n        },\n        set(newValue) {\n            const vm = getComponentVM(this);\n            if (true) {\n                assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n                assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${toString(key)}`);\n            }\n            if (vm.isRoot || isBeingConstructed(vm)) {\n                vmBeingUpdated = vm;\n                if (true) {\n                    // reactiveMembrane.getProxy(newValue) will return a different value (proxy)\n                    // Then newValue if newValue is observable (plain object or array)\n                    const isObservable = reactiveMembrane.getProxy(newValue) !== newValue;\n                    if (!isObservable && !isNull(newValue) && isObject(newValue)) {\n                        assert.logWarning(`Assigning a non-reactive value ${newValue} to member property ${toString(key)} of ${vm} is not common because mutations on that value cannot be observed.`, vm.elm);\n                    }\n                }\n            }\n            if (true) {\n                if (vmBeingUpdated !== vm) {\n                    // logic for setting new properties of the element directly from the DOM\n                    // is only recommended for root elements created via createElement()\n                    assert.logWarning(`If property ${toString(key)} decorated with @api in ${vm} is used in the template, the value ${toString(newValue)} set manually may be overridden by the template, consider binding the property only in the template.`, vm.elm);\n                }\n            }\n            vmBeingUpdated = null; // releasing the lock\n            // not need to wrap or check the value since that is happening somewhere else\n            if (set) {\n                set.call(this, reactiveMembrane.getReadOnlyProxy(newValue));\n            }\n            else if (true) {\n                assert.fail(`Invalid attempt to set a new value for property ${toString(key)} of ${vm} that does not has a setter decorated with @api.`);\n            }\n        },\n        enumerable,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst EspecialTagAndPropMap = create(null, {\n    input: { value: create(null, { value: { value: 1 }, checked: { value: 1 } }) },\n    select: { value: create(null, { value: { value: 1 } }) },\n    textarea: { value: create(null, { value: { value: 1 } }) },\n});\nfunction isLiveBindingProp(sel, key) {\n    // For special whitelisted properties (e.g., `checked` and `value`), we\n    // check against the actual property value on the DOM element instead of\n    // relying on tracked property values.\n    return (hasOwnProperty.call(EspecialTagAndPropMap, sel) &&\n        hasOwnProperty.call(EspecialTagAndPropMap[sel], key));\n}\nfunction update(oldVnode, vnode) {\n    const props = vnode.data.props;\n    if (isUndefined(props)) {\n        return;\n    }\n    const oldProps = oldVnode.data.props;\n    if (oldProps === props) {\n        return;\n    }\n    if (true) {\n        assert.invariant(isUndefined(oldProps) || keys(oldProps).join(',') === keys(props).join(','), 'vnode.data.props cannot change shape.');\n    }\n    const elm = vnode.elm;\n    const vm = getInternalField(elm, ViewModelReflection);\n    const isFirstPatch = isUndefined(oldProps);\n    const isCustomElement = !isUndefined(vm);\n    const { sel } = vnode;\n    for (const key in props) {\n        const cur = props[key];\n        if (true) {\n            if (!(key in elm)) {\n                // TODO: this should never really happen because the compiler should always validate\n                assert.fail(`Unknown public property \"${key}\" of element <${sel}>. This is likely a typo on the corresponding attribute \"${getAttrNameFromPropName(key)}\".`);\n            }\n        }\n        // if it is the first time this element is patched, or the current value is different to the previous value...\n        if (isFirstPatch || cur !== (isLiveBindingProp(sel, key) ? elm[key] : oldProps[key])) {\n            if (isCustomElement) {\n                prepareForPropUpdate(vm); // this is just in case the vnode is actually a custom element\n            }\n            elm[key] = cur;\n        }\n    }\n}\nconst emptyVNode$1 = { data: {} };\nvar modProps = {\n    create: (vnode) => update(emptyVNode$1, vnode),\n    update,\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst classNameToClassMap = create(null);\nfunction getMapFromClassName(className) {\n    // Intentionally using == to match undefined and null values from computed style attribute\n    if (className == null) {\n        return EmptyObject;\n    }\n    // computed class names must be string\n    className = isString(className) ? className : className + '';\n    let map = classNameToClassMap[className];\n    if (map) {\n        return map;\n    }\n    map = create(null);\n    let start = 0;\n    let o;\n    const len = className.length;\n    for (o = 0; o < len; o++) {\n        if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {\n            if (o > start) {\n                map[StringSlice.call(className, start, o)] = true;\n            }\n            start = o + 1;\n        }\n    }\n    if (o > start) {\n        map[StringSlice.call(className, start, o)] = true;\n    }\n    classNameToClassMap[className] = map;\n    if (true) {\n        // just to make sure that this object never changes as part of the diffing algo\n        freeze(map);\n    }\n    return map;\n}\nfunction updateClassAttribute(oldVnode, vnode) {\n    const { elm, data: { className: newClass } } = vnode;\n    const { data: { className: oldClass } } = oldVnode;\n    if (oldClass === newClass) {\n        return;\n    }\n    const { classList } = elm;\n    const newClassMap = getMapFromClassName(newClass);\n    const oldClassMap = getMapFromClassName(oldClass);\n    let name;\n    for (name in oldClassMap) {\n        // remove only if it is not in the new class collection and it is not set from within the instance\n        if (isUndefined(newClassMap[name])) {\n            classList.remove(name);\n        }\n    }\n    for (name in newClassMap) {\n        if (isUndefined(oldClassMap[name])) {\n            classList.add(name);\n        }\n    }\n}\nconst emptyVNode$2 = { data: {} };\nvar modComputedClassName = {\n    create: (vnode) => updateClassAttribute(emptyVNode$2, vnode),\n    update: updateClassAttribute\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The style property is a string when defined via an expression in the template.\nfunction updateStyleAttribute(oldVnode, vnode) {\n    const { style: newStyle } = vnode.data;\n    if (oldVnode.data.style === newStyle) {\n        return;\n    }\n    const elm = vnode.elm;\n    const { style } = elm;\n    if (!isString(newStyle) || newStyle === '') {\n        removeAttribute.call(elm, 'style');\n    }\n    else {\n        style.cssText = newStyle;\n    }\n}\nconst emptyVNode$3 = { data: {} };\nvar modComputedStyle = {\n    create: (vnode) => updateStyleAttribute(emptyVNode$3, vnode),\n    update: updateStyleAttribute,\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The HTML class property becomes the vnode.data.classMap object when defined as a string in the template.\n// The compiler takes care of transforming the inline classnames into an object. It's faster to set the\n// different classnames properties individually instead of via a string.\nfunction createClassAttribute(vnode) {\n    const { elm, data: { classMap } } = vnode;\n    if (isUndefined(classMap)) {\n        return;\n    }\n    const { classList } = elm;\n    for (const name in classMap) {\n        classList.add(name);\n    }\n}\nvar modStaticClassName = {\n    create: createClassAttribute,\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// The HTML style property becomes the vnode.data.styleMap object when defined as a string in the template.\n// The compiler takes care of transforming the inline style into an object. It's faster to set the\n// different style properties individually instead of via a string.\nfunction createStyleAttribute(vnode) {\n    const { elm, data: { styleMap } } = vnode;\n    if (isUndefined(styleMap)) {\n        return;\n    }\n    const { style } = elm;\n    for (const name in styleMap) {\n        style[name] = styleMap[name];\n    }\n}\nvar modStaticStyle = {\n    create: createStyleAttribute,\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction createContext(vnode) {\n    const { data: { context } } = vnode;\n    if (isUndefined(context)) {\n        return;\n    }\n    const elm = vnode.elm;\n    const vm = getInternalField(elm, ViewModelReflection);\n    if (!isUndefined(vm)) {\n        assign(vm.context, context);\n    }\n}\nconst contextModule = {\n    create: createContext,\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet MO = window.MutationObserver;\n// MutationObserver is not yet implemented in jsdom:\n// https://github.com/jsdom/jsdom/issues/639\nif (typeof MO === 'undefined') {\n    /* tslint:disable-next-line:no-empty */\n    function MutationObserverMock() { }\n    MutationObserverMock.prototype = {\n        observe() {\n            if (true) {\n                if (true) {\n                    throw new Error(`MutationObserver should not be mocked outside of the jest test environment`);\n                }\n            }\n        }\n    };\n    MO = window.MutationObserver = MutationObserverMock;\n}\nconst MutationObserver = MO;\nconst MutationObserverObserve = MutationObserver.prototype.observe;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getTextContent(node) {\n    switch (node.nodeType) {\n        case Node.ELEMENT_NODE:\n            const childNodes = getFilteredChildNodes(node);\n            let content = '';\n            for (let i = 0, len = childNodes.length; i < len; i += 1) {\n                content += getTextContent(childNodes[i]);\n            }\n            return content;\n        default:\n            return node.nodeValue;\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst Items = createFieldName('items');\n// tslint:disable-next-line:no-empty\nfunction StaticNodeList() {\n    throw new TypeError('Illegal constructor');\n}\nStaticNodeList.prototype = create(NodeList.prototype, {\n    constructor: {\n        writable: true,\n        configurable: true,\n        value: StaticNodeList,\n    },\n    item: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(index) {\n            return this[index];\n        },\n    },\n    length: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return getInternalField(this, Items).length;\n        },\n    },\n    // Iterator protocol\n    forEach: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(cb, thisArg) {\n            forEach.call(getInternalField(this, Items), cb, thisArg);\n        },\n    },\n    entries: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            return ArrayMap.call(getInternalField(this, Items), (v, i) => [i, v]);\n        },\n    },\n    keys: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            return ArrayMap.call(getInternalField(this, Items), (v, i) => i);\n        },\n    },\n    values: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            return getInternalField(this, Items);\n        },\n    },\n    [Symbol.iterator]: {\n        writable: true,\n        configurable: true,\n        value() {\n            let nextIndex = 0;\n            return {\n                next: () => {\n                    const items = getInternalField(this, Items);\n                    return nextIndex < items.length\n                        ? {\n                            value: items[nextIndex++],\n                            done: false,\n                        }\n                        : {\n                            done: true,\n                        };\n                },\n            };\n        },\n    },\n});\n// prototype inheritance dance\nsetPrototypeOf(StaticNodeList, NodeList);\nfunction createStaticNodeList(items) {\n    const nodeList = create(StaticNodeList.prototype, {\n        [Items]: {\n            value: items,\n        }\n    });\n    // setting static indexes\n    forEach.call(items, (item, index) => {\n        defineProperty(nodeList, index, {\n            value: item,\n            enumerable: true,\n            configurable: true,\n        });\n    });\n    return nodeList;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst DocumentPrototypeActiveElement = getOwnPropertyDescriptor(Document.prototype, 'activeElement').get;\nconst elementFromPoint = hasOwnProperty.call(Document.prototype, 'elementFromPoint') ?\n    Document.prototype.elementFromPoint :\n    Document.prototype.msElementFromPoint; // IE11\nconst { createDocumentFragment, createElement, createElementNS, createTextNode, createComment, querySelector: querySelector$1, querySelectorAll: querySelectorAll$1, getElementById, getElementsByClassName: getElementsByClassName$1, getElementsByName, getElementsByTagName: getElementsByTagName$1, getElementsByTagNameNS: getElementsByTagNameNS$1, } = Document.prototype;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst Items$1 = createFieldName('items');\nfunction isValidHTMLCollectionName(name) {\n    return name !== 'length' && isNaN(name);\n}\nfunction getNodeHTMLCollectionName(node) {\n    return node.getAttribute('id') || node.getAttribute('name');\n}\nfunction StaticHTMLCollection() {\n    throw new TypeError('Illegal constructor');\n}\nStaticHTMLCollection.prototype = create(HTMLCollection.prototype, {\n    constructor: {\n        writable: true,\n        configurable: true,\n        value: StaticHTMLCollection,\n    },\n    item: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(index) {\n            return this[index];\n        },\n    },\n    length: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return getInternalField(this, Items$1).length;\n        },\n    },\n    // https://dom.spec.whatwg.org/#dom-htmlcollection-nameditem-key\n    namedItem: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(name) {\n            if (isValidHTMLCollectionName(name) && this[name]) {\n                return this[name];\n            }\n            const items = getInternalField(this, Items$1);\n            // Note: loop in reverse so that the first named item matches the named property\n            for (let len = items.length - 1; len >= 0; len -= 1) {\n                const item = items[len];\n                const nodeName = getNodeHTMLCollectionName(item);\n                if (nodeName === name) {\n                    return item;\n                }\n            }\n            return null;\n        },\n    },\n    // Iterator protocol\n    forEach: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(cb, thisArg) {\n            forEach.call(getInternalField(this, Items$1), cb, thisArg);\n        },\n    },\n    entries: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            return ArrayMap.call(getInternalField(this, Items$1), (v, i) => [i, v]);\n        },\n    },\n    keys: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            return ArrayMap.call(getInternalField(this, Items$1), (v, i) => i);\n        },\n    },\n    values: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            return getInternalField(this, Items$1);\n        },\n    },\n    [Symbol.iterator]: {\n        writable: true,\n        configurable: true,\n        value() {\n            let nextIndex = 0;\n            return {\n                next: () => {\n                    const items = getInternalField(this, Items$1);\n                    return nextIndex < items.length\n                        ? {\n                            value: items[nextIndex++],\n                            done: false,\n                        }\n                        : {\n                            done: true,\n                        };\n                },\n            };\n        },\n    },\n});\n// prototype inheritance dance\nsetPrototypeOf(StaticHTMLCollection, HTMLCollection);\nfunction createStaticHTMLCollection(items) {\n    const collection = create(StaticHTMLCollection.prototype, {\n        [Items$1]: {\n            value: items,\n        }\n    });\n    // setting static indexes\n    forEach.call(items, (item, index) => {\n        defineProperty(collection, index, {\n            value: item,\n            enumerable: true,\n            configurable: true,\n        });\n    });\n    return collection;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getInnerHTML(node) {\n    let s = '';\n    const childNodes = getFilteredChildNodes(node);\n    for (let i = 0, len = childNodes.length; i < len; i += 1) {\n        s += getOuterHTML(childNodes[i]);\n    }\n    return s;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\nconst escapeAttrRegExp = /[&\\u00A0\"]/g;\nconst escapeDataRegExp = /[&\\u00A0<>]/g;\nconst { replace, toLowerCase } = String.prototype;\nfunction escapeReplace(c) {\n    switch (c) {\n        case '&':\n            return '&amp;';\n        case '<':\n            return '&lt;';\n        case '>':\n            return '&gt;';\n        case '\"':\n            return '&quot;';\n        case '\\u00A0':\n            return '&nbsp;';\n    }\n}\nfunction escapeAttr(s) {\n    return replace.call(s, escapeAttrRegExp, escapeReplace);\n}\nfunction escapeData(s) {\n    return replace.call(s, escapeDataRegExp, escapeReplace);\n}\n// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\nconst voidElements = new Set([\n    'AREA',\n    'BASE',\n    'BR',\n    'COL',\n    'COMMAND',\n    'EMBED',\n    'HR',\n    'IMG',\n    'INPUT',\n    'KEYGEN',\n    'LINK',\n    'META',\n    'PARAM',\n    'SOURCE',\n    'TRACK',\n    'WBR'\n]);\nconst plaintextParents = new Set([\n    'STYLE',\n    'SCRIPT',\n    'XMP',\n    'IFRAME',\n    'NOEMBED',\n    'NOFRAMES',\n    'PLAINTEXT',\n    'NOSCRIPT'\n]);\nfunction getOuterHTML(node) {\n    switch (node.nodeType) {\n        case Node.ELEMENT_NODE: {\n            const { attributes: attrs } = node;\n            const tagName = tagNameGetter.call(node);\n            let s = '<' + toLowerCase.call(tagName);\n            for (let i = 0, attr; (attr = attrs[i]); i++) {\n                s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n            }\n            s += '>';\n            if (voidElements.has(tagName)) {\n                return s;\n            }\n            return s + getInnerHTML(node) + '</' + toLowerCase.call(tagName) + '>';\n        }\n        case Node.TEXT_NODE: {\n            const { data, parentNode } = node;\n            if (parentNode instanceof Element && plaintextParents.has(tagNameGetter.call(parentNode))) {\n                return data;\n            }\n            return escapeData(data);\n        }\n        case Node.COMMENT_NODE: {\n            return '<!--' + node.data + '-->';\n        }\n        default: {\n            throw new Error();\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nfunction pathComposer(startNode, composed) {\n    const composedPath = [];\n    let current = startNode;\n    const startRoot = startNode === window ? window : getRootNodeGetter.call(startNode);\n    while (current) {\n        composedPath.push(current);\n        if (current.assignedSlot) {\n            current = current.assignedSlot;\n        }\n        else if (current.nodeType === DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n            current = current.host;\n        }\n        else {\n            current = current.parentNode;\n        }\n    }\n    // event composedPath includes window when startNode's ownerRoot is document\n    if (composedPath[composedPath.length - 1] === document) {\n        composedPath.push(window);\n    }\n    return composedPath;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\nfunction retarget(refNode, path) {\n    // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n    // shadow-including inclusive ancestor, return ANCESTOR.\n    const refNodePath = pathComposer(refNode, true);\n    const p$ = path;\n    for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n        ancestor = p$[i];\n        root = ancestor === window ? window : getRootNodeGetter.call(ancestor);\n        if (root !== lastRoot) {\n            rootIdx = refNodePath.indexOf(root);\n            lastRoot = root;\n        }\n        if (!(root instanceof SyntheticShadowRoot) || rootIdx > -1) {\n            return ancestor;\n        }\n    }\n    return null;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst HostKey = createFieldName('host');\nconst ShadowRootKey = createFieldName('shadowRoot');\nconst { createDocumentFragment: createDocumentFragment$1 } = document;\nfunction isDelegatingFocus(host) {\n    const shadowRoot = getShadowRoot(host);\n    return shadowRoot.delegatesFocus;\n}\nfunction getHost(root) {\n    if (true) {\n        assert.invariant(root[HostKey], `A 'ShadowRoot' node must be attached to an 'HTMLElement' node.`);\n    }\n    return root[HostKey];\n}\nfunction getShadowRoot(elm) {\n    if (true) {\n        assert.invariant(getInternalField(elm, ShadowRootKey), `A Custom Element with a shadow attached must be provided as the first argument.`);\n    }\n    return getInternalField(elm, ShadowRootKey);\n}\nfunction attachShadow(elm, options) {\n    if (getInternalField(elm, ShadowRootKey)) {\n        throw new Error(`Failed to execute 'attachShadow' on 'Element': Shadow root cannot be created on a host which already hosts a shadow tree.`);\n    }\n    const { mode, delegatesFocus } = options;\n    // creating a real fragment for shadowRoot instance\n    const sr = createDocumentFragment$1.call(document);\n    defineProperty(sr, 'mode', {\n        get() { return mode; },\n        configurable: true,\n        enumerable: true,\n    });\n    defineProperty(sr, 'delegatesFocus', {\n        get() { return !!delegatesFocus; },\n        configurable: true,\n        enumerable: true,\n    });\n    // correcting the proto chain\n    setPrototypeOf(sr, SyntheticShadowRoot.prototype);\n    setInternalField(sr, HostKey, elm);\n    setInternalField(elm, ShadowRootKey, sr);\n    // expose the shadow via a hidden symbol for testing purposes\n    if (false) {}\n    return sr;\n}\nvar ShadowRootMode;\n(function (ShadowRootMode) {\n    ShadowRootMode[\"CLOSED\"] = \"closed\";\n    ShadowRootMode[\"OPEN\"] = \"open\";\n})(ShadowRootMode || (ShadowRootMode = {}));\nconst SyntheticShadowRootDescriptors = {\n    constructor: {\n        writable: true,\n        configurable: true,\n        value: SyntheticShadowRoot,\n    },\n    toString: {\n        writable: true,\n        configurable: true,\n        value() {\n            return `[object ShadowRoot]`;\n        },\n    },\n};\nconst ShadowRootDescriptors = {\n    activeElement: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const activeElement = DocumentPrototypeActiveElement.call(document);\n            if (isNull(activeElement)) {\n                return activeElement;\n            }\n            const host = getHost(this);\n            if ((compareDocumentPosition.call(host, activeElement) &\n                DOCUMENT_POSITION_CONTAINED_BY) ===\n                0) {\n                return null;\n            }\n            // activeElement must be child of the host and owned by it\n            let node = activeElement;\n            while (!isNodeOwnedBy(host, node)) {\n                node = parentElementGetter.call(node);\n            }\n            // If we have a slot element here that means that we were dealing\n            // with an element that was passed to one of our slots. In this\n            // case, activeElement returns null.\n            if (isSlotElement(node)) {\n                return null;\n            }\n            return node;\n        },\n    },\n    delegatesFocus: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return false;\n        },\n    },\n    elementFromPoint: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(left, top) {\n            const element = elementFromPoint.call(document, left, top);\n            if (isNull(element)) {\n                return element;\n            }\n            return retarget(this, pathComposer(element, true));\n        },\n    },\n    elementsFromPoint: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(left, top) {\n            throw new Error();\n        },\n    },\n    getSelection: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            throw new Error();\n        },\n    },\n    host: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return getHost(this);\n        },\n    },\n    mode: {\n        configurable: true,\n        get() {\n            return ShadowRootMode.OPEN;\n        },\n    },\n    styleSheets: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            throw new Error();\n        },\n    },\n};\nconst NodePatchDescriptors = {\n    addEventListener: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(type, listener, options) {\n            addShadowRootEventListener(this, type, listener, options);\n        },\n    },\n    removeEventListener: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(type, listener, options) {\n            removeShadowRootEventListener(this, type, listener, options);\n        },\n    },\n    baseURI: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return getHost(this).baseURI;\n        },\n    },\n    childNodes: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return createStaticNodeList(shadowRootChildNodes(this));\n        },\n    },\n    compareDocumentPosition: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(otherNode) {\n            const host = getHost(this);\n            if (this === otherNode) {\n                // it is the root itself\n                return 0;\n            }\n            if (this.contains(otherNode)) {\n                // it belongs to the shadow root instance\n                return 20; // 10100 === DOCUMENT_POSITION_FOLLOWING & DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\n            }\n            else if (compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) {\n                // it is a child element but does not belong to the shadow root instance\n                return 37; // 100101 === DOCUMENT_POSITION_DISCONNECTED & DOCUMENT_POSITION_FOLLOWING & DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\n            }\n            else {\n                // it is not a descendant\n                return 35; // 100011 === DOCUMENT_POSITION_DISCONNECTED & DOCUMENT_POSITION_PRECEDING & DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC\n            }\n        },\n    },\n    contains: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(otherNode) {\n            const host = getHost(this);\n            // must be child of the host and owned by it.\n            return ((compareDocumentPosition.call(host, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !==\n                0 && isNodeOwnedBy(host, otherNode));\n        },\n    },\n    firstChild: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const { childNodes } = this;\n            return childNodes[0] || null;\n        },\n    },\n    lastChild: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const { childNodes } = this;\n            return childNodes[childNodes.length - 1] || null;\n        },\n    },\n    hasChildNodes: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value() {\n            return this.childNodes.length > 0;\n        },\n    },\n    isConnected: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return ((compareDocumentPosition.call(document, getHost(this)) &\n                DOCUMENT_POSITION_CONTAINED_BY) !==\n                0);\n        },\n    },\n    nextSibling: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    previousSibling: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    nodeName: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return '#document-fragment';\n        },\n    },\n    nodeType: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return 11; // Node.DOCUMENT_FRAGMENT_NODE\n        },\n    },\n    nodeValue: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    ownerDocument: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return getHost(this).ownerDocument;\n        },\n    },\n    parentElement: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    parentNode: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    textContent: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const { childNodes } = this;\n            let textContent = '';\n            for (let i = 0, len = childNodes.length; i < len; i += 1) {\n                textContent += getTextContent(childNodes[i]);\n            }\n            return textContent;\n        },\n    },\n    getRootNode: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(options) {\n            return getRootNodeGetter.call(this, options);\n        },\n    },\n};\nconst ElementPatchDescriptors = {\n    innerHTML: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const { childNodes } = this;\n            let innerHTML = '';\n            for (let i = 0, len = childNodes.length; i < len; i += 1) {\n                innerHTML += getOuterHTML(childNodes[i]);\n            }\n            return innerHTML;\n        },\n    },\n    localName: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    namespaceURI: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    nextElementSibling: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    previousElementSibling: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n    prefix: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return null;\n        },\n    },\n};\nconst ParentNodePatchDescriptors = {\n    childElementCount: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return this.children.length;\n        },\n    },\n    children: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return createStaticHTMLCollection(ArrayFilter.call(shadowRootChildNodes(this), (elm) => elm instanceof Element));\n        },\n    },\n    firstElementChild: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return this.children[0] || null;\n        },\n    },\n    lastElementChild: {\n        enumerable: true,\n        configurable: true,\n        get() {\n            const { children } = this;\n            return children.item(children.length - 1) || null;\n        },\n    },\n    querySelector: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(selectors) {\n            return shadowRootQuerySelector(this, selectors);\n        },\n    },\n    querySelectorAll: {\n        writable: true,\n        enumerable: true,\n        configurable: true,\n        value(selectors) {\n            return createStaticNodeList(shadowRootQuerySelectorAll(this, selectors));\n        },\n    },\n};\nassign(SyntheticShadowRootDescriptors, NodePatchDescriptors, ParentNodePatchDescriptors, ElementPatchDescriptors, ShadowRootDescriptors);\nfunction SyntheticShadowRoot() {\n    throw new TypeError('Illegal constructor');\n}\nSyntheticShadowRoot.prototype = create(DocumentFragment.prototype, SyntheticShadowRootDescriptors);\n// Is native ShadowDom is available on window,\n// we need to make sure that our synthetic shadow dom\n// passed instanceof checks against window.ShadowDom\nif (isNativeShadowRootAvailable) {\n    setPrototypeOf(SyntheticShadowRoot.prototype, window.ShadowRoot.prototype);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// DO NOT CHANGE this:\n// these two values need to be in sync with framework/vm.ts\nconst OwnerKey = '$$OwnerKey$$';\nconst OwnKey = '$$OwnKey$$';\nfunction getNodeOwnerKey(node) {\n    return node[OwnerKey];\n}\nfunction setNodeOwnerKey(node, key) {\n    node[OwnerKey] = key;\n}\nfunction getNodeNearestOwnerKey(node) {\n    let ownerKey;\n    // search for the first element with owner identity (just in case of manually inserted elements)\n    while (!isNull(node) && isUndefined((ownerKey = node[OwnerKey]))) {\n        node = parentNodeGetter.call(node);\n    }\n    return ownerKey;\n}\nfunction getNodeKey(node) {\n    return node[OwnKey];\n}\nconst portals = new WeakMap();\n// We can use a single observer without having to worry about leaking because\n// \"Registered observers in a nodes registered observer list have a weak\n// reference to the node.\"\n// https://dom.spec.whatwg.org/#garbage-collection\nlet portalObserver;\nconst portalObserverConfig = {\n    childList: true,\n    subtree: true,\n};\nfunction patchPortalElement(node, ownerKey, shadowToken) {\n    // If node aleady has an ownerkey, we can skip\n    // Note: checking if a node as any ownerKey is not enough\n    // because this element could be moved from one\n    // shadow to another\n    if (getNodeOwnerKey(node) === ownerKey) {\n        return;\n    }\n    setNodeOwnerKey(node, ownerKey);\n    if (node instanceof Element) {\n        setCSSToken(node, shadowToken);\n        const { childNodes } = node;\n        for (let i = 0, len = childNodes.length; i < len; i += 1) {\n            const child = childNodes[i];\n            patchPortalElement(child, ownerKey, shadowToken);\n        }\n    }\n}\nfunction initPortalObserver() {\n    return new MutationObserver(mutations => {\n        forEach.call(mutations, mutation => {\n            const { target: elm, addedNodes } = mutation;\n            const ownerKey = getNodeOwnerKey(elm);\n            const shadowToken = getCSSToken(elm);\n            // OwnerKey might be undefined at this point.\n            // We used to throw an error here, but we need to return early instead.\n            //\n            // This routine results in a mutation target that will have no key\n            // because its been removed by the time the observer runs\n            // const div = document.createElement('div');\n            // div.innerHTML = '<span>span</span>';\n            // const span = div.querySelector('span');\n            // manualElement.appendChild(div);\n            // span.textContent = '';\n            // span.parentNode.removeChild(span);\n            if (isUndefined(ownerKey)) {\n                return;\n            }\n            for (let i = 0, len = addedNodes.length; i < len; i += 1) {\n                const node = addedNodes[i];\n                patchPortalElement(node, ownerKey, shadowToken);\n            }\n        });\n    });\n}\nconst ShadowTokenKey = '$$ShadowTokenKey$$';\nfunction setCSSToken(elm, shadowToken) {\n    if (!isUndefined(shadowToken)) {\n        setAttribute.call(elm, shadowToken, '');\n        elm[ShadowTokenKey] = shadowToken;\n    }\n}\nfunction getCSSToken(elm) {\n    return elm[ShadowTokenKey];\n}\nfunction markElementAsPortal(elm) {\n    portals.set(elm, 1);\n    if (!portalObserver) {\n        portalObserver = initPortalObserver();\n    }\n    // install mutation observer for portals\n    MutationObserverObserve.call(portalObserver, elm, portalObserverConfig);\n}\nfunction getShadowParent(node, value) {\n    const owner = getNodeOwner(node);\n    if (value === owner) {\n        // walking up via parent chain might end up in the shadow root element\n        return getShadowRoot(owner);\n    }\n    else if (value instanceof Element) {\n        if (getNodeNearestOwnerKey(node) === getNodeNearestOwnerKey(value)) {\n            // the element and its parent node belong to the same shadow root\n            return value;\n        }\n        else if (!isNull(owner) && isSlotElement(value)) {\n            // slotted elements must be top level childNodes of the slot element\n            // where they slotted into, but its shadowed parent is always the\n            // owner of the slot.\n            const slotOwner = getNodeOwner(value);\n            if (!isNull(slotOwner) && isNodeOwnedBy(owner, slotOwner)) {\n                // it is a slotted element, and therefore its parent is always going to be the host of the slot\n                return slotOwner;\n            }\n        }\n    }\n    return null;\n}\nfunction PatchedNode(node) {\n    const Ctor = getPrototypeOf(node).constructor;\n    class PatchedNodeClass {\n        constructor() {\n            // Patched classes are not supposed to be instantiated directly, ever!\n            throw new TypeError('Illegal constructor');\n        }\n        hasChildNodes() {\n            return this.childNodes.length > 0;\n        }\n        // @ts-ignore until ts@3.x\n        get firstChild() {\n            const { childNodes } = this;\n            // @ts-ignore until ts@3.x\n            return childNodes[0] || null;\n        }\n        // @ts-ignore until ts@3.x\n        get lastChild() {\n            const { childNodes } = this;\n            // @ts-ignore until ts@3.x\n            return childNodes[childNodes.length - 1] || null;\n        }\n        get textContent() {\n            return getTextContent(this);\n        }\n        set textContent(value) {\n            textContextSetter.call(this, value);\n        }\n        get childElementCount() {\n            return this.children.length;\n        }\n        get firstElementChild() {\n            return this.children[0] || null;\n        }\n        get lastElementChild() {\n            const { children } = this;\n            return children.item(children.length - 1) || null;\n        }\n        get assignedSlot() {\n            const parentNode = parentNodeGetter.call(this);\n            /**\n             * if it doesn't have a parent node,\n             * or the parent is not an slot element\n             * or they both belong to the same template (default content)\n             * we should assume that it is not slotted\n             */\n            if (isNull(parentNode) || !isSlotElement(parentNode) || getNodeNearestOwnerKey(parentNode) === getNodeNearestOwnerKey(this)) {\n                return null;\n            }\n            return parentNode;\n        }\n        get parentNode() {\n            const value = parentNodeGetter.call(this);\n            if (isNull(value)) {\n                return value;\n            }\n            return getShadowParent(this, value);\n        }\n        get parentElement() {\n            const parentNode = parentNodeGetter.call(this);\n            if (isNull(parentNode)) {\n                return null;\n            }\n            const nodeOwner = getNodeOwner(this);\n            if (isNull(nodeOwner)) {\n                return parentNode;\n            }\n            // If we have traversed to the host element,\n            // we need to return null\n            if (nodeOwner === parentNode) {\n                return null;\n            }\n            return parentNode;\n        }\n        getRootNode(options) {\n            return getRootNodeGetter.call(this, options);\n        }\n        compareDocumentPosition(otherNode) {\n            if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {\n                // it is from another shadow\n                return 0;\n            }\n            return compareDocumentPosition.call(this, otherNode);\n        }\n        contains(otherNode) {\n            if (getNodeOwnerKey(this) !== getNodeOwnerKey(otherNode)) {\n                // it is from another shadow\n                return false;\n            }\n            return (compareDocumentPosition.call(this, otherNode) & DOCUMENT_POSITION_CONTAINED_BY) !== 0;\n        }\n        cloneNode(deep) {\n            const clone = cloneNode.call(this, false);\n            // Per spec, browsers only care about truthy values\n            // Not strict true or false\n            if (!deep) {\n                return clone;\n            }\n            const childNodes = this.childNodes;\n            for (let i = 0, len = childNodes.length; i < len; i += 1) {\n                clone.appendChild(childNodes[i].cloneNode(true));\n            }\n            return clone;\n        }\n    }\n    // prototype inheritance dance\n    setPrototypeOf(PatchedNodeClass, Ctor);\n    setPrototypeOf(PatchedNodeClass.prototype, Ctor.prototype);\n    return PatchedNodeClass;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction wrapIframeWindow(win) {\n    return {\n        postMessage() {\n            return win.postMessage.apply(win, arguments);\n        },\n        blur() {\n            return win.blur.apply(win, arguments);\n        },\n        close() {\n            return win.close.apply(win, arguments);\n        },\n        focus() {\n            return win.focus.apply(win, arguments);\n        },\n        get closed() {\n            return win.closed;\n        },\n        get frames() {\n            return win.frames;\n        },\n        get length() {\n            return win.length;\n        },\n        get location() {\n            return win.location;\n        },\n        set location(value) {\n            win.location = value;\n        },\n        get opener() {\n            return win.opener;\n        },\n        get parent() {\n            return win.parent;\n        },\n        get self() {\n            return win.self;\n        },\n        get top() {\n            return win.top;\n        },\n        get window() {\n            return win.window;\n        },\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// We can use a single observer without having to worry about leaking because\n// \"Registered observers in a nodes registered observer list have a weak\n// reference to the node.\"\n// https://dom.spec.whatwg.org/#garbage-collection\nlet observer;\nconst observerConfig = { childList: true };\nconst SlotChangeKey = createFieldName('slotchange');\nfunction initSlotObserver() {\n    return new MutationObserver(mutations => {\n        const slots = [];\n        forEach.call(mutations, mutation => {\n            if (true) {\n                assert.isTrue(mutation.type === 'childList', `Invalid mutation type: ${mutation.type}. This mutation handler for slots should only handle \"childList\" mutations.`);\n            }\n            const { target: slot } = mutation;\n            if (ArrayIndexOf.call(slots, slot) === -1) {\n                ArrayPush.call(slots, slot);\n                dispatchEvent.call(slot, new CustomEvent('slotchange'));\n            }\n        });\n    });\n}\nfunction getFilteredSlotAssignedNodes(slot) {\n    const owner = getNodeOwner(slot);\n    if (isNull(owner)) {\n        return [];\n    }\n    return ArrayReduce.call(childNodesGetter.call(slot), (seed, child) => {\n        if (!isNodeOwnedBy(owner, child)) {\n            ArrayPush.call(seed, child);\n        }\n        return seed;\n    }, []);\n}\nfunction getFilteredSlotFlattenNodes(slot) {\n    return ArrayReduce.call(childNodesGetter.call(slot), (seed, child) => {\n        if (child instanceof Element && isSlotElement(child)) {\n            ArrayPush.apply(seed, getFilteredSlotFlattenNodes(child));\n        }\n        else {\n            ArrayPush.call(seed, child);\n        }\n        return seed;\n    }, []);\n}\nfunction PatchedSlotElement(elm) {\n    const Ctor = PatchedElement(elm);\n    const { addEventListener: superAddEventListener } = elm;\n    return class PatchedHTMLSlotElement extends Ctor {\n        addEventListener(type, listener, options) {\n            if (type === 'slotchange' && !getInternalField(this, SlotChangeKey)) {\n                if (false) {}\n                setInternalField(this, SlotChangeKey, true);\n                if (!observer) {\n                    observer = initSlotObserver();\n                }\n                MutationObserverObserve.call(observer, this, observerConfig);\n            }\n            superAddEventListener.call(this, type, listener, options);\n        }\n        assignedElements(options) {\n            const flatten = !isUndefined(options) && isTrue(options.flatten);\n            const nodes = flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);\n            return ArrayFilter.call(nodes, node => node instanceof Element);\n        }\n        assignedNodes(options) {\n            const flatten = !isUndefined(options) && isTrue(options.flatten);\n            return flatten ? getFilteredSlotFlattenNodes(this) : getFilteredSlotAssignedNodes(this);\n        }\n        get name() {\n            // in browsers that do not support shadow dom, slot's name attribute is not reflective\n            const name = getAttribute.call(this, 'name');\n            return isNull(name) ? '' : name;\n        }\n        get childNodes() {\n            const owner = getNodeOwner(this);\n            const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));\n            return createStaticNodeList(childNodes);\n        }\n        get children() {\n            // We cannot patch `children` in test mode\n            // because JSDOM uses children for its \"native\"\n            // querySelector implementation. If we patch this,\n            // HTMLElement.prototype.querySelector.call(element) will not\n            // return any elements from shadow, which is not what we want\n            if (false) {}\n            const owner = getNodeOwner(this);\n            const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));\n            return createStaticHTMLCollection(ArrayFilter.call(childNodes, (node) => node instanceof Element));\n        }\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getNodeOwner(node) {\n    if (!(node instanceof Node)) {\n        return null;\n    }\n    const ownerKey = getNodeNearestOwnerKey(node);\n    if (isUndefined(ownerKey)) {\n        return null;\n    }\n    // At this point, node is a valid node with owner identity, now we need to find the owner node\n    // search for a custom element with a VM that owns the first element with owner identity attached to it\n    while (!isNull(node) && (getNodeKey(node) !== ownerKey)) {\n        node = parentNodeGetter.call(node);\n    }\n    if (isNull(node)) {\n        return null;\n    }\n    return node;\n}\nfunction isSlotElement(elm) {\n    return tagNameGetter.call(elm) === 'SLOT';\n}\nfunction isNodeOwnedBy(owner, node) {\n    if (true) {\n        assert.invariant(owner instanceof HTMLElement, `isNodeOwnedBy() should be called with an element as the first argument instead of ${owner}`);\n        assert.invariant(node instanceof Node, `isNodeOwnedBy() should be called with a node as the second argument instead of ${node}`);\n        assert.isTrue(compareDocumentPosition.call(node, owner) & DOCUMENT_POSITION_CONTAINS, `isNodeOwnedBy() should never be called with a node that is not a child node of ${owner}`);\n    }\n    const ownerKey = getNodeNearestOwnerKey(node);\n    return isUndefined(ownerKey) || getNodeKey(owner) === ownerKey;\n}\nfunction isNodeSlotted(host, node) {\n    if (true) {\n        assert.invariant(host instanceof HTMLElement, `isNodeSlotted() should be called with a host as the first argument instead of ${host}`);\n        assert.invariant(node instanceof Node, `isNodeSlotted() should be called with a node as the second argument instead of ${node}`);\n        assert.isTrue(compareDocumentPosition.call(node, host) & DOCUMENT_POSITION_CONTAINS, `isNodeSlotted() should never be called with a node that is not a child node of ${host}`);\n    }\n    const hostKey = getNodeKey(host);\n    // just in case the provided node is not an element\n    let currentElement = node instanceof Element ? node : parentElementGetter.call(node);\n    while (!isNull(currentElement) && currentElement !== host) {\n        const elmOwnerKey = getNodeNearestOwnerKey(currentElement);\n        const parent = parentElementGetter.call(currentElement);\n        if (elmOwnerKey === hostKey) {\n            // we have reached a host's node element, and only if\n            // that element is an slot, then the node is considered slotted\n            return isSlotElement(currentElement);\n        }\n        else if (parent !== host && getNodeNearestOwnerKey(parent) !== elmOwnerKey) {\n            // we are crossing a boundary of some sort since the elm and its parent\n            // have different owner key. for slotted elements, this is only possible\n            // if the parent happens to be a slot that is not owned by the host\n            if (!isSlotElement(parent)) {\n                return false;\n            }\n        }\n        currentElement = parent;\n    }\n    return false;\n}\nfunction shadowRootChildNodes(root) {\n    const elm = getHost(root);\n    return getAllMatches(elm, childNodesGetter.call(elm));\n}\nfunction getAllMatches(owner, nodeList) {\n    const filteredAndPatched = [];\n    for (let i = 0, len = nodeList.length; i < len; i += 1) {\n        const node = nodeList[i];\n        const isOwned = isNodeOwnedBy(owner, node);\n        if (isOwned) {\n            // Patch querySelector, querySelectorAll, etc\n            // if element is owned by VM\n            ArrayPush.call(filteredAndPatched, node);\n        }\n    }\n    return filteredAndPatched;\n}\nfunction getRoot(node) {\n    const ownerNode = getNodeOwner(node);\n    if (isNull(ownerNode)) {\n        // we hit a wall, is not in lwc boundary.\n        return getShadowIncludingRoot(node);\n    }\n    // @ts-ignore: Attributes property is removed from Node (https://developer.mozilla.org/en-US/docs/Web/API/Node)\n    return getShadowRoot(ownerNode);\n}\nfunction getShadowIncludingRoot(node) {\n    let nodeParent;\n    while (!isNull(nodeParent = parentNodeGetter.call(node))) {\n        node = nodeParent;\n    }\n    return node;\n}\n/**\n * Dummy implementation of the Node.prototype.getRootNode.\n * Spec: https://dom.spec.whatwg.org/#dom-node-getrootnode\n *\n * TODO: Once we start using the real shadowDOM, this method should be replaced by:\n * const { getRootNode } = Node.prototype;\n */\nfunction getRootNodeGetter(options) {\n    const composed = isUndefined(options) ? false : !!options.composed;\n    return isTrue(composed) ?\n        getShadowIncludingRoot(this) :\n        getRoot(this);\n}\nfunction getFirstMatch(owner, nodeList) {\n    for (let i = 0, len = nodeList.length; i < len; i += 1) {\n        if (isNodeOwnedBy(owner, nodeList[i])) {\n            return nodeList[i];\n        }\n    }\n    return null;\n}\nfunction getAllSlottedMatches(host, nodeList) {\n    const filteredAndPatched = [];\n    for (let i = 0, len = nodeList.length; i < len; i += 1) {\n        const node = nodeList[i];\n        if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {\n            ArrayPush.call(filteredAndPatched, node);\n        }\n    }\n    return filteredAndPatched;\n}\nfunction getFirstSlottedMatch(host, nodeList) {\n    for (let i = 0, len = nodeList.length; i < len; i += 1) {\n        const node = nodeList[i];\n        if (!isNodeOwnedBy(host, node) && isNodeSlotted(host, node)) {\n            return node;\n        }\n    }\n    return null;\n}\nfunction lightDomQuerySelectorAll(elm, selectors) {\n    const owner = getNodeOwner(elm);\n    if (isNull(owner)) {\n        return [];\n    }\n    const nodeList = querySelectorAll.call(elm, selectors);\n    if (getNodeKey(elm)) {\n        // it is a custom element, and we should then filter by slotted elements\n        return getAllSlottedMatches(elm, nodeList);\n    }\n    else {\n        // regular element, we should then filter by ownership\n        return getAllMatches(owner, nodeList);\n    }\n}\nfunction lightDomQuerySelector(elm, selector) {\n    const owner = getNodeOwner(elm);\n    if (isNull(owner)) {\n        // the it is a root, and those can't have a lightdom\n        return null;\n    }\n    const nodeList = querySelectorAll.call(elm, selector);\n    if (getNodeKey(elm)) {\n        // it is a custom element, and we should then filter by slotted elements\n        return getFirstSlottedMatch(elm, nodeList);\n    }\n    else {\n        // regular element, we should then filter by ownership\n        return getFirstMatch(owner, nodeList);\n    }\n}\nfunction shadowRootQuerySelector(root, selector) {\n    const elm = getHost(root);\n    const nodeList = querySelectorAll.call(elm, selector);\n    return getFirstMatch(elm, nodeList);\n}\nfunction shadowRootQuerySelectorAll(root, selector) {\n    const elm = getHost(root);\n    const nodeList = querySelectorAll.call(elm, selector);\n    return getAllMatches(elm, nodeList);\n}\nfunction getFilteredChildNodes(node) {\n    let children;\n    if (!isUndefined(getNodeKey(node))) {\n        // node itself is a custom element\n        // lwc element, in which case we need to get only the nodes\n        // that were slotted\n        const slots = querySelectorAll.call(node, 'slot');\n        children = ArrayReduce.call(slots, (seed, slot) => {\n            if (isNodeOwnedBy(node, slot)) {\n                ArrayPush.apply(seed, getFilteredSlotAssignedNodes(slot));\n            }\n            return seed;\n        }, []);\n    }\n    else {\n        // regular element\n        children = childNodesGetter.call(node);\n    }\n    const owner = getNodeOwner(node);\n    if (isNull(owner)) {\n        return [];\n    }\n    return ArrayReduce.call(children, (seed, child) => {\n        if (isNodeOwnedBy(owner, child)) {\n            ArrayPush.call(seed, child);\n        }\n        return seed;\n    }, []);\n}\nfunction PatchedElement(elm) {\n    const Ctor = PatchedNode(elm);\n    // @ts-ignore type-mismatch\n    return class PatchedHTMLElement extends Ctor {\n        querySelector(selector) {\n            return lightDomQuerySelector(this, selector);\n        }\n        querySelectorAll(selectors) {\n            return createStaticNodeList(lightDomQuerySelectorAll(this, selectors));\n        }\n        get innerHTML() {\n            const { childNodes } = this;\n            let innerHTML = '';\n            for (let i = 0, len = childNodes.length; i < len; i += 1) {\n                innerHTML += getOuterHTML(childNodes[i]);\n            }\n            return innerHTML;\n        }\n        set innerHTML(value) {\n            innerHTMLSetter.call(this, value);\n        }\n        get outerHTML() {\n            return getOuterHTML(this);\n        }\n    };\n}\nfunction PatchedIframeElement(elm) {\n    const Ctor = PatchedElement(elm);\n    return class PatchedHTMLIframeElement extends Ctor {\n        get contentWindow() {\n            const original = iFrameContentWindowGetter.call(this);\n            if (original) {\n                return wrapIframeWindow(original);\n            }\n            return original;\n        }\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nvar EventListenerContext;\n(function (EventListenerContext) {\n    EventListenerContext[EventListenerContext[\"CUSTOM_ELEMENT_LISTENER\"] = 1] = \"CUSTOM_ELEMENT_LISTENER\";\n    EventListenerContext[EventListenerContext[\"SHADOW_ROOT_LISTENER\"] = 2] = \"SHADOW_ROOT_LISTENER\";\n})(EventListenerContext || (EventListenerContext = {}));\nconst eventToContextMap = new WeakMap();\nfunction isChildNode(root, node) {\n    return !!(compareDocumentPosition.call(root, node) & DOCUMENT_POSITION_CONTAINED_BY);\n}\nconst GET_ROOT_NODE_CONFIG_FALSE = { composed: false };\nfunction getRootNodeHost(node, options) {\n    let rootNode = getRootNodeGetter.call(node, options);\n    // is SyntheticShadowRootInterface\n    if ('mode' in rootNode && 'delegatesFocus' in rootNode) {\n        rootNode = getHost(rootNode);\n    }\n    return rootNode;\n}\nfunction patchEvent(event) {\n    if (eventToContextMap.has(event)) {\n        return; // already patched\n    }\n    // not all events implement the relatedTarget getter, that's why we need to extract it from the instance\n    // Note: we can't really use the super here because of issues with the typescript transpilation for accessors\n    const originalRelatedTargetDescriptor = getPropertyDescriptor(event, 'relatedTarget');\n    defineProperties(event, {\n        relatedTarget: {\n            get() {\n                const eventContext = eventToContextMap.get(this);\n                const originalCurrentTarget = eventCurrentTargetGetter.call(this);\n                if (isUndefined(originalRelatedTargetDescriptor)) {\n                    return undefined;\n                }\n                const relatedTarget = originalRelatedTargetDescriptor.get.call(this);\n                if (isNull(relatedTarget)) {\n                    return null;\n                }\n                const currentTarget = (eventContext === EventListenerContext.SHADOW_ROOT_LISTENER) ?\n                    getShadowRoot(originalCurrentTarget) :\n                    originalCurrentTarget;\n                return retarget(currentTarget, pathComposer(relatedTarget, true));\n            },\n            enumerable: true,\n            configurable: true,\n        },\n        target: {\n            get() {\n                const originalCurrentTarget = eventCurrentTargetGetter.call(this);\n                const originalTarget = eventTargetGetter.call(this);\n                const composedPath = pathComposer(originalTarget, this.composed);\n                // Handle cases where the currentTarget is null (for async events),\n                // and when an event has been added to Window\n                if (!(originalCurrentTarget instanceof Node)) {\n                    return retarget(document, composedPath);\n                }\n                const eventContext = eventToContextMap.get(this);\n                const currentTarget = (eventContext === EventListenerContext.SHADOW_ROOT_LISTENER) ?\n                    getShadowRoot(originalCurrentTarget) :\n                    originalCurrentTarget;\n                return retarget(currentTarget, composedPath);\n            },\n            enumerable: true,\n            configurable: true,\n        },\n    });\n    eventToContextMap.set(event, 0);\n}\nconst customElementToWrappedListeners = new WeakMap();\nfunction getEventMap(elm) {\n    let listenerInfo = customElementToWrappedListeners.get(elm);\n    if (isUndefined(listenerInfo)) {\n        listenerInfo = create(null);\n        customElementToWrappedListeners.set(elm, listenerInfo);\n    }\n    return listenerInfo;\n}\nconst shadowRootEventListenerMap = new WeakMap();\nfunction getWrappedShadowRootListener(sr, listener) {\n    if (!isFunction(listener)) {\n        throw new TypeError(); // avoiding problems with non-valid listeners\n    }\n    let shadowRootWrappedListener = shadowRootEventListenerMap.get(listener);\n    if (isUndefined(shadowRootWrappedListener)) {\n        shadowRootWrappedListener = function (event) {\n            // * if the event is dispatched directly on the host, it is not observable from root\n            // * if the event is dispatched in an element that does not belongs to the shadow and it is not composed,\n            //   it is not observable from the root\n            const { composed } = event;\n            const target = eventTargetGetter.call(event);\n            const currentTarget = eventCurrentTargetGetter.call(event);\n            if (target !== currentTarget) {\n                const rootNode = getRootNodeHost(target, { composed });\n                if (isChildNode(rootNode, currentTarget) ||\n                    (composed === false && rootNode === currentTarget)) {\n                    listener.call(sr, event);\n                }\n            }\n        };\n        shadowRootWrappedListener.placement = EventListenerContext.SHADOW_ROOT_LISTENER;\n        if (true) {\n            shadowRootWrappedListener.original = listener; // for logging purposes\n        }\n        shadowRootEventListenerMap.set(listener, shadowRootWrappedListener);\n    }\n    return shadowRootWrappedListener;\n}\nconst customElementEventListenerMap = new WeakMap();\nfunction getWrappedCustomElementListener(elm, listener) {\n    if (!isFunction(listener)) {\n        throw new TypeError(); // avoiding problems with non-valid listeners\n    }\n    let customElementWrappedListener = customElementEventListenerMap.get(listener);\n    if (isUndefined(customElementWrappedListener)) {\n        customElementWrappedListener = function (event) {\n            if (isValidEventForCustomElement(event)) {\n                // all handlers on the custom element should be called with undefined 'this'\n                listener.call(elm, event);\n            }\n        };\n        customElementWrappedListener.placement = EventListenerContext.CUSTOM_ELEMENT_LISTENER;\n        if (true) {\n            customElementWrappedListener.original = listener; // for logging purposes\n        }\n        customElementEventListenerMap.set(listener, customElementWrappedListener);\n    }\n    return customElementWrappedListener;\n}\nfunction domListener(evt) {\n    let immediatePropagationStopped = false;\n    let propagationStopped = false;\n    const { type, stopImmediatePropagation, stopPropagation } = evt;\n    const currentTarget = eventCurrentTargetGetter.call(evt);\n    const listenerMap = getEventMap(currentTarget);\n    const listeners = listenerMap[type]; // it must have listeners at this point\n    defineProperty(evt, 'stopImmediatePropagation', {\n        value() {\n            immediatePropagationStopped = true;\n            stopImmediatePropagation.call(evt);\n        },\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    });\n    defineProperty(evt, 'stopPropagation', {\n        value() {\n            propagationStopped = true;\n            stopPropagation.call(evt);\n        },\n        writable: true,\n        enumerable: true,\n        configurable: true,\n    });\n    patchEvent(evt);\n    // in case a listener adds or removes other listeners during invocation\n    const bookkeeping = ArraySlice.call(listeners);\n    function invokeListenersByPlacement(placement) {\n        forEach.call(bookkeeping, (listener) => {\n            if (isFalse(immediatePropagationStopped) && listener.placement === placement) {\n                // making sure that the listener was not removed from the original listener queue\n                if (ArrayIndexOf.call(listeners, listener) !== -1) {\n                    // all handlers on the custom element should be called with undefined 'this'\n                    listener.call(undefined, evt);\n                }\n            }\n        });\n    }\n    eventToContextMap.set(evt, EventListenerContext.SHADOW_ROOT_LISTENER);\n    invokeListenersByPlacement(EventListenerContext.SHADOW_ROOT_LISTENER);\n    if (isFalse(immediatePropagationStopped) && isFalse(propagationStopped)) {\n        // doing the second iteration only if the first one didn't interrupt the event propagation\n        eventToContextMap.set(evt, EventListenerContext.CUSTOM_ELEMENT_LISTENER);\n        invokeListenersByPlacement(EventListenerContext.CUSTOM_ELEMENT_LISTENER);\n    }\n    eventToContextMap.set(evt, 0);\n}\nfunction attachDOMListener(elm, type, wrappedListener) {\n    const listenerMap = getEventMap(elm);\n    let cmpEventHandlers = listenerMap[type];\n    if (isUndefined(cmpEventHandlers)) {\n        cmpEventHandlers = listenerMap[type] = [];\n    }\n    // only add to DOM if there is no other listener on the same placement yet\n    if (cmpEventHandlers.length === 0) {\n        addEventListener.call(elm, type, domListener);\n    }\n    else if (true) {\n        if (ArrayIndexOf.call(cmpEventHandlers, wrappedListener) !== -1) {\n            assert.logWarning(`${toString(elm)} has duplicate listener for event \"${type}\". Instead add the event listener in the connectedCallback() hook.`, elm);\n        }\n    }\n    ArrayPush.call(cmpEventHandlers, wrappedListener);\n}\nfunction detachDOMListener(elm, type, wrappedListener) {\n    const listenerMap = getEventMap(elm);\n    let p;\n    let listeners;\n    if (!isUndefined(listeners = listenerMap[type]) && (p = ArrayIndexOf.call(listeners, wrappedListener)) !== -1) {\n        ArraySplice.call(listeners, p, 1);\n        // only remove from DOM if there is no other listener on the same placement\n        if (listeners.length === 0) {\n            removeEventListener.call(elm, type, domListener);\n        }\n    }\n    else if (true) {\n        assert.logError(`Did not find event listener for event \"${type}\" executing removeEventListener on ${toString(elm)}. This is probably a typo or a life cycle mismatch. Make sure that you add the right event listeners in the connectedCallback() hook and remove them in the disconnectedCallback() hook.`, elm);\n    }\n}\nfunction isValidEventForCustomElement(event) {\n    const target = eventTargetGetter.call(event);\n    const currentTarget = eventCurrentTargetGetter.call(event);\n    const { composed } = event;\n    return (\n    // it is composed, and we should always get it, or\n    composed === true ||\n        // it is dispatched onto the custom element directly, or\n        target === currentTarget ||\n        // it is coming from a slotted element\n        isChildNode(getRootNodeHost(target, GET_ROOT_NODE_CONFIG_FALSE), currentTarget));\n}\nfunction addCustomElementEventListener(elm, type, listener, options) {\n    if (true) {\n        assert.invariant(isFunction(listener), `Invalid second argument for this.template.addEventListener() in ${toString(elm)} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n        // TODO: issue #420\n        // this is triggered when the component author attempts to add a listener programmatically into a lighting element node\n        if (!isUndefined(options)) {\n            assert.logWarning(`The 'addEventListener' method in 'LightningElement' does not support more than 2 arguments. Options to make the listener passive, once, or capture are not allowed but received: ${toString(options)}`, elm);\n        }\n    }\n    const wrappedListener = getWrappedCustomElementListener(elm, listener);\n    attachDOMListener(elm, type, wrappedListener);\n}\nfunction removeCustomElementEventListener(elm, type, listener, options) {\n    const wrappedListener = getWrappedCustomElementListener(elm, listener);\n    detachDOMListener(elm, type, wrappedListener);\n}\nfunction addShadowRootEventListener(sr, type, listener, options) {\n    if (true) {\n        assert.invariant(isFunction(listener), `Invalid second argument for this.template.addEventListener() in ${toString(sr)} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n        // TODO: issue #420\n        // this is triggered when the component author attempts to add a listener programmatically into its Component's shadow root\n        if (!isUndefined(options)) {\n            assert.logWarning(`The 'addEventListener' method in 'ShadowRoot' does not support more than 2 arguments. Options to make the listener passive, once, or capture are not allowed but received: ${toString(options)}`, getHost(sr));\n        }\n    }\n    const elm = getHost(sr);\n    const wrappedListener = getWrappedShadowRootListener(sr, listener);\n    attachDOMListener(elm, type, wrappedListener);\n}\nfunction removeShadowRootEventListener(sr, type, listener, options) {\n    const elm = getHost(sr);\n    const wrappedListener = getWrappedShadowRootListener(sr, listener);\n    detachDOMListener(elm, type, wrappedListener);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst TabbableElementsQuery = `\n    button:not([tabindex=\"-1\"]):not([disabled]),\n    [contenteditable]:not([tabindex=\"-1\"]),\n    video[controls]:not([tabindex=\"-1\"]),\n    audio[controls]:not([tabindex=\"-1\"]),\n    [href]:not([tabindex=\"-1\"]),\n    input:not([tabindex=\"-1\"]):not([disabled]),\n    select:not([tabindex=\"-1\"]):not([disabled]),\n    textarea:not([tabindex=\"-1\"]):not([disabled]),\n    [tabindex=\"0\"]\n`;\nfunction isVisible(element) {\n    const { width, height } = getBoundingClientRect.call(element);\n    const noZeroSize = width > 0 || height > 0;\n    return (noZeroSize &&\n        getComputedStyle(element).visibility !== 'hidden');\n}\nfunction hasFocusableTabIndex(element) {\n    if (isFalse(hasAttribute.call(element, 'tabindex'))) {\n        return false;\n    }\n    const value = getAttribute.call(element, 'tabindex');\n    // Really, any numeric tabindex value is valid\n    // But LWC only allows 0 or -1, so we can just check against that.\n    // The main point here is to make sure the tabindex attribute is not an invalid\n    // value like tabindex=\"hello\"\n    if (value === '' || (value !== '0' && value !== '-1')) {\n        return false;\n    }\n    return true;\n}\n// This function based on https://allyjs.io/data-tables/focusable.html\n// It won't catch everything, but should be good enough\n// There are a lot of edge cases here that we can't realistically handle\n// Determines if a particular element is tabbable, as opposed to simply focusable\n// Exported for jest purposes\nfunction isTabbable(element) {\n    return matches.call(element, TabbableElementsQuery) && isVisible(element);\n}\nconst focusableTagNames = {\n    IFRAME: 1,\n    VIDEO: 1,\n    AUDIO: 1,\n    A: 1,\n    INPUT: 1,\n    SELECT: 1,\n    TEXTAREA: 1,\n    BUTTON: 1,\n};\n// This function based on https://allyjs.io/data-tables/focusable.html\n// It won't catch everything, but should be good enough\n// There are a lot of edge cases here that we can't realistically handle\n// Exported for jest purposes\nfunction isFocusable(element) {\n    const tagName = tagNameGetter.call(element);\n    return ((isVisible(element)) && (hasFocusableTabIndex(element) ||\n        hasAttribute.call(element, 'contenteditable') ||\n        hasOwnProperty.call(focusableTagNames, tagName)));\n}\nfunction getFirstTabbableMatch(elements) {\n    for (let i = 0, len = elements.length; i < len; i += 1) {\n        const elm = elements[i];\n        if (isTabbable(elm)) {\n            return elm;\n        }\n    }\n    return null;\n}\nfunction getLastTabbableMatch(elements) {\n    for (let i = elements.length - 1; i >= 0; i -= 1) {\n        const elm = elements[i];\n        if (isTabbable(elm)) {\n            return elm;\n        }\n    }\n    return null;\n}\nfunction getTabbableSegments(host) {\n    const all = querySelectorAll$1.call(document, TabbableElementsQuery);\n    const inner = querySelectorAll.call(host, TabbableElementsQuery);\n    if (true) {\n        assert.invariant(tabIndexGetter.call(host) === -1 || isDelegatingFocus(host), `The focusin event is only relevant when the tabIndex property is -1 on the host.`);\n    }\n    const firstChild = inner[0];\n    const lastChild = inner[inner.length - 1];\n    const hostIndex = ArrayIndexOf.call(all, host);\n    // Host element can show up in our \"previous\" section if its tabindex is 0\n    // We want to filter that out here\n    const firstChildIndex = (hostIndex > -1) ? hostIndex : ArrayIndexOf.call(all, firstChild);\n    // Account for an empty inner list\n    const lastChildIndex = inner.length === 0 ? firstChildIndex + 1 : ArrayIndexOf.call(all, lastChild) + 1;\n    const prev = ArraySlice.call(all, 0, firstChildIndex);\n    const next = ArraySlice.call(all, lastChildIndex);\n    return {\n        prev,\n        inner,\n        next,\n    };\n}\nfunction getActiveElement(host) {\n    const activeElement = DocumentPrototypeActiveElement.call(document);\n    if (isNull(activeElement)) {\n        return activeElement;\n    }\n    // activeElement must be child of the host and owned by it\n    return (compareDocumentPosition.call(host, activeElement) & DOCUMENT_POSITION_CONTAINED_BY) !== 0 ? activeElement : null;\n}\nfunction relatedTargetPosition(host, relatedTarget) {\n    // assert: target must be child of host\n    const pos = compareDocumentPosition.call(host, relatedTarget);\n    if (pos & DOCUMENT_POSITION_CONTAINED_BY) {\n        // focus remains inside the host\n        return 0;\n    }\n    else if (pos & DOCUMENT_POSITION_PRECEDING) {\n        // focus is coming from above\n        return 1;\n    }\n    else if (pos & DOCUMENT_POSITION_FOLLOWING) {\n        // focus is coming from below\n        return 2;\n    }\n    // we don't know what's going on.\n    return -1;\n}\nfunction getPreviousTabbableElement(segments) {\n    const { prev } = segments;\n    return getFirstTabbableMatch(ArrayReverse.call(prev));\n}\nfunction getNextTabbableElement(segments) {\n    const { next } = segments;\n    return getFirstTabbableMatch(next);\n}\nfunction focusOnNextOrBlur(focusEventTarget, segments) {\n    const nextNode = getNextTabbableElement(segments);\n    if (isNull(nextNode)) {\n        // nothing to focus on, blur to invalidate the operation\n        focusEventTarget.blur();\n        return;\n    }\n    nextNode.focus();\n}\nfunction focusOnPrevOrBlur(focusEventTarget, segments) {\n    const prevNode = getPreviousTabbableElement(segments);\n    if (isNull(prevNode)) {\n        // nothing to focus on, blur to invalidate the operation\n        focusEventTarget.blur();\n        return;\n    }\n    prevNode.focus();\n}\nfunction isFirstTabbableChild(target, segments) {\n    return getFirstTabbableMatch(segments.inner) === target;\n}\nfunction isLastTabbableChild(target, segments) {\n    return getLastTabbableMatch(segments.inner) === target;\n}\nfunction keyboardFocusHandler(event) {\n    const host = eventCurrentTargetGetter.call(event);\n    const target = eventTargetGetter.call(event);\n    // Ideally, we would be able to use a \"focus\" event that doesn't bubble\n    // but, IE11 doesn't support relatedTarget on focus events so we have to use\n    // focusin instead. The logic below is predicated on non-bubbling events\n    // So, if currentTarget(host) ir not target, we know that the event is bubbling\n    // and we escape because focus occured on something below the host.\n    if (host !== target) {\n        return;\n    }\n    const relatedTarget = focusEventRelatedTargetGetter.call(event);\n    if (isNull(relatedTarget)) {\n        return;\n    }\n    const segments = getTabbableSegments(host);\n    const position = relatedTargetPosition(host, relatedTarget);\n    if (position === 1) {\n        // probably tabbing into element\n        const first = getFirstTabbableMatch(segments.inner);\n        if (!isNull(first)) {\n            first.focus();\n        }\n        else {\n            focusOnNextOrBlur(target, segments);\n        }\n        return;\n    }\n    else if (host === target) { // Shift tabbed back to the host\n        focusOnPrevOrBlur(host, segments);\n    }\n}\n// focusin handler for custom elements\n// This handler should only be called when a user\n// focuses on either the custom element, or an internal element\n// via keyboard navigation (tab or shift+tab)\n// Focusing via mouse should be disqualified before this gets called\nfunction keyboardFocusInHandler(event) {\n    const host = eventCurrentTargetGetter.call(event);\n    const target = eventTargetGetter.call(event);\n    const relatedTarget = focusEventRelatedTargetGetter.call(event);\n    const segments = getTabbableSegments(host);\n    const isFirstFocusableChildReceivingFocus = isFirstTabbableChild(target, segments);\n    const isLastFocusableChildReceivingFocus = isLastTabbableChild(target, segments);\n    if (\n    // If we receive a focusin event that is not focusing on the first or last\n    // element inside of a shadow, we can assume that the user is tabbing between\n    // elements inside of the custom element shadow, so we do nothing\n    (isFalse(isFirstFocusableChildReceivingFocus) && isFalse(isLastFocusableChildReceivingFocus)) ||\n        // If related target is null, user is probably tabbing into the document from the browser chrome (location bar?)\n        // If relatedTarget is null, we can't do much here because we don't know what direction the user is tabbing\n        // This is a bit of an edge case, and only comes up if the custom element is the very first or very last\n        // tabbable element in a document\n        isNull(relatedTarget)) {\n        return;\n    }\n    // Determine where the focus is coming from (Tab or Shift+Tab)\n    const post = relatedTargetPosition(host, relatedTarget);\n    switch (post) {\n        case 1: // focus is probably coming from above\n            if (isFirstFocusableChildReceivingFocus && relatedTarget === getPreviousTabbableElement(segments)) {\n                // the focus was on the immediate focusable elements from above,\n                // it is almost certain that the focus is due to tab keypress\n                focusOnNextOrBlur(target, segments);\n            }\n            break;\n        case 2: // focus is probably coming from below\n            if (isLastFocusableChildReceivingFocus && relatedTarget === getNextTabbableElement(segments)) {\n                // the focus was on the immediate focusable elements from above,\n                // it is almost certain that the focus is due to tab keypress\n                focusOnPrevOrBlur(target, segments);\n            }\n            break;\n    }\n}\nfunction willTriggerFocusInEvent(target) {\n    return (target !== DocumentPrototypeActiveElement.call(document) && // if the element is currently active, it will not fire a focusin event\n        isFocusable(target));\n}\nfunction stopFocusIn(evt) {\n    const currentTarget = eventCurrentTargetGetter.call(evt);\n    removeEventListener.call(currentTarget, 'focusin', keyboardFocusInHandler);\n    setTimeout(() => {\n        // only reinstate the focus if the tabindex is still -1\n        if (tabIndexGetter.call(currentTarget) === -1) {\n            addEventListener.call(currentTarget, 'focusin', keyboardFocusInHandler);\n        }\n    }, 0);\n}\nfunction handleFocusMouseDown(evt) {\n    const target = eventTargetGetter.call(evt);\n    // If we are mouse down in an element that can be focused\n    // and the currentTarget's activeElement is not element we are mouse-ing down in\n    // We can bail out and let the browser do its thing.\n    if (willTriggerFocusInEvent(target)) {\n        addEventListener.call(eventCurrentTargetGetter.call(evt), 'focusin', stopFocusIn, true);\n    }\n}\nfunction handleFocus(elm) {\n    if (true) {\n        assert.invariant(isDelegatingFocus(elm), `Invalid attempt to handle focus event for ${toString(elm)}. ${toString(elm)} should have delegates focus true, but is not delegating focus`);\n    }\n    // Unbind any focusin listeners we may have going on\n    ignoreFocusIn(elm);\n    addEventListener.call(elm, 'focusin', keyboardFocusHandler, true);\n}\nfunction ignoreFocus(elm) {\n    removeEventListener.call(elm, 'focusin', keyboardFocusHandler, true);\n}\nfunction handleFocusIn(elm) {\n    if (true) {\n        assert.invariant(tabIndexGetter.call(elm) === -1, `Invalid attempt to handle focus in  ${toString(elm)}. ${toString(elm)} should have tabIndex -1, but has tabIndex ${tabIndexGetter.call(elm)}`);\n    }\n    // Unbind any focus listeners we may have going on\n    ignoreFocus(elm);\n    // We want to listen for mousedown\n    // If the user is triggering a mousedown event on an element\n    // That can trigger a focus event, then we need to opt out\n    // of our tabindex -1 dance. The tabindex -1 only applies for keyboard navigation\n    addEventListener.call(elm, 'mousedown', handleFocusMouseDown, true);\n    // This focusin listener is to catch focusin events from keyboard interactions\n    // A better solution would perhaps be to listen for keydown events, but\n    // the keydown event happens on whatever element already has focus (or no element\n    // at all in the case of the location bar. So, instead we have to assume that focusin\n    // without a mousedown means keyboard navigation\n    addEventListener.call(elm, 'focusin', keyboardFocusInHandler);\n}\nfunction ignoreFocusIn(elm) {\n    if (true) {\n        assert.invariant(tabIndexGetter.call(elm) !== -1, `Invalid attempt to ignore focus in  ${toString(elm)}. ${toString(elm)} should not have tabIndex -1`);\n    }\n    removeEventListener.call(elm, 'focusin', keyboardFocusInHandler);\n    removeEventListener.call(elm, 'mousedown', handleFocusMouseDown, true);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction PatchedCustomElement(Base) {\n    const Ctor = PatchedElement(Base);\n    return class PatchedHTMLElement extends Ctor {\n        attachShadow(options) {\n            return attachShadow(this, options);\n        }\n        addEventListener(type, listener, options) {\n            addCustomElementEventListener(this, type, listener, options);\n        }\n        removeEventListener(type, listener, options) {\n            removeCustomElementEventListener(this, type, listener, options);\n        }\n        get shadowRoot() {\n            const shadow = getShadowRoot(this);\n            if (shadow.mode === ShadowRootMode.OPEN) {\n                return shadow;\n            }\n            return null;\n        }\n        get tabIndex() {\n            if (isDelegatingFocus(this) && isFalse(hasAttribute.call(this, 'tabindex'))) {\n                // this cover the case where the default tabindex should be 0 because the\n                // custom element is delegating its focus\n                return 0;\n            }\n            // NOTE: Technically this should be `super.tabIndex` however Typescript\n            // has a known bug while transpiling down to ES5\n            // https://github.com/Microsoft/TypeScript/issues/338\n            const descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');\n            return descriptor.get.call(this);\n        }\n        set tabIndex(value) {\n            // get the original value from the element before changing it, just in case\n            // the custom element is doing something funky. we only really care about\n            // the actual changes in the DOM.\n            const hasAttr = hasAttribute.call(this, 'tabindex');\n            const originalValue = tabIndexGetter.call(this);\n            // run the super logic, which bridges the setter to the component\n            // NOTE: Technically this should be `super.tabIndex` however Typescript\n            // has a known bug while transpiling down to ES5\n            // https://github.com/Microsoft/TypeScript/issues/338\n            const descriptor = getPropertyDescriptor(Ctor.prototype, 'tabIndex');\n            descriptor.set.call(this, value);\n            // Check if the value from the dom has changed\n            const newValue = tabIndexGetter.call(this);\n            if ((!hasAttr || originalValue !== newValue)) {\n                // Value has changed\n                if (newValue === -1) {\n                    // add the magic to skip this element\n                    handleFocusIn(this);\n                }\n                else if (newValue === 0 && isDelegatingFocus(this)) {\n                    // Listen for focus if the new tabIndex is 0, and we are delegating focus\n                    handleFocus(this);\n                }\n                else {\n                    // TabIndex is set to 0, but we aren't delegating focus, so we can ignore everything\n                    ignoreFocusIn(this);\n                    ignoreFocus(this);\n                }\n            }\n            else if (originalValue === -1) {\n                // remove the magic\n                ignoreFocusIn(this);\n                ignoreFocus(this);\n            }\n        }\n        blur() {\n            if (isDelegatingFocus(this)) {\n                const currentActiveElement = getActiveElement(this);\n                if (!isNull(currentActiveElement)) {\n                    // if there is an active element, blur it\n                    currentActiveElement.blur();\n                    return;\n                }\n            }\n            super.blur();\n        }\n        get childNodes() {\n            const owner = getNodeOwner(this);\n            const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));\n            return createStaticNodeList(childNodes);\n        }\n        get children() {\n            // We cannot patch `children` in test mode\n            // because JSDOM uses children for its \"native\"\n            // querySelector implementation. If we patch this,\n            // HTMLElement.prototype.querySelector.call(element) will not\n            // return any elements from shadow, which is not what we want\n            if (false) {}\n            const owner = getNodeOwner(this);\n            const childNodes = isNull(owner) ? [] : getAllMatches(owner, getFilteredChildNodes(this));\n            return createStaticHTMLCollection(ArrayFilter.call(childNodes, (node) => node instanceof Element));\n        }\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n@license\nCopyright (c) 2015 Simon Friis Vindum.\nThis code may only be used under the MIT License found at\nhttps://github.com/snabbdom/snabbdom/blob/master/LICENSE\nCode distributed by Snabbdom as part of the Snabbdom project at\nhttps://github.com/snabbdom/snabbdom/\n*/\nfunction isUndef(s) {\n    return s === undefined;\n}\nfunction sameVnode(vnode1, vnode2) {\n    return (vnode1.key === vnode2.key &&\n        vnode1.sel === vnode2.sel);\n}\nfunction isVNode(vnode) {\n    return vnode != null;\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    const map = {};\n    let j, key, ch;\n    // TODO: simplify this by assuming that all vnodes has keys\n    for (j = beginIdx; j <= endIdx; ++j) {\n        ch = children[j];\n        if (isVNode(ch)) {\n            key = ch.key;\n            if (key !== undefined) {\n                map[key] = j;\n            }\n        }\n    }\n    return map;\n}\nfunction addVnodes(parentElm, before, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n        const ch = vnodes[startIdx];\n        if (isVNode(ch)) {\n            ch.hook.create(ch);\n            ch.hook.insert(ch, parentElm, before);\n        }\n    }\n}\nfunction removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n        const ch = vnodes[startIdx];\n        // text nodes do not have logic associated to them\n        if (isVNode(ch)) {\n            ch.hook.remove(ch, parentElm);\n        }\n    }\n}\nfunction updateDynamicChildren(parentElm, oldCh, newCh) {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let oldKeyToIdx;\n    let idxInOld;\n    let elmToMove;\n    let before;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (!isVNode(oldStartVnode)) {\n            oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n        }\n        else if (!isVNode(oldEndVnode)) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (!isVNode(newStartVnode)) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (!isVNode(newEndVnode)) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (sameVnode(oldStartVnode, newStartVnode)) {\n            patchVnode(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (sameVnode(oldEndVnode, newEndVnode)) {\n            patchVnode(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (sameVnode(oldStartVnode, newEndVnode)) {\n            // Vnode moved right\n            patchVnode(oldStartVnode, newEndVnode);\n            newEndVnode.hook.move(oldStartVnode, parentElm, \n            // TODO: resolve this, but using dot notation for nextSibling for now\n            oldEndVnode.elm.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (sameVnode(oldEndVnode, newStartVnode)) {\n            // Vnode moved left\n            patchVnode(oldEndVnode, newStartVnode);\n            newStartVnode.hook.move(oldEndVnode, parentElm, oldStartVnode.elm);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            if (oldKeyToIdx === undefined) {\n                oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n            }\n            idxInOld = oldKeyToIdx[newStartVnode.key];\n            if (isUndef(idxInOld)) {\n                // New element\n                newStartVnode.hook.create(newStartVnode);\n                newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                elmToMove = oldCh[idxInOld];\n                if (isVNode(elmToMove)) {\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        // New element\n                        newStartVnode.hook.create(newStartVnode);\n                        newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);\n                    }\n                    else {\n                        patchVnode(elmToMove, newStartVnode);\n                        oldCh[idxInOld] = undefined;\n                        newStartVnode.hook.move(elmToMove, parentElm, oldStartVnode.elm);\n                    }\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n        }\n    }\n    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {\n        if (oldStartIdx > oldEndIdx) {\n            const n = newCh[newEndIdx + 1];\n            before = isVNode(n) ? n.elm : null;\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);\n        }\n        else {\n            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n        }\n    }\n}\nfunction updateStaticChildren(parentElm, oldCh, newCh) {\n    const { length } = newCh;\n    if (oldCh.length === 0) {\n        // the old list is empty, we can directly insert anything new\n        addVnodes(parentElm, null, newCh, 0, length);\n        return;\n    }\n    // if the old list is not empty, the new list MUST have the same\n    // amount of nodes, that's why we call this static children\n    let referenceElm = null;\n    for (let i = length - 1; i >= 0; i -= 1) {\n        const vnode = newCh[i];\n        const oldVNode = oldCh[i];\n        if (vnode !== oldVNode) {\n            if (isVNode(oldVNode)) {\n                if (isVNode(vnode)) {\n                    // both vnodes must be equivalent, and se just need to patch them\n                    patchVnode(oldVNode, vnode);\n                    referenceElm = vnode.elm;\n                }\n                else {\n                    // removing the old vnode since the new one is null\n                    oldVNode.hook.remove(oldVNode, parentElm);\n                }\n            }\n            else if (isVNode(vnode)) { // this condition is unnecessary\n                vnode.hook.create(vnode);\n                // insert the new node one since the old one is null\n                vnode.hook.insert(vnode, parentElm, referenceElm);\n                referenceElm = vnode.elm;\n            }\n        }\n    }\n}\nfunction patchVnode(oldVnode, vnode) {\n    if (oldVnode !== vnode) {\n        vnode.elm = oldVnode.elm;\n        vnode.hook.update(oldVnode, vnode);\n    }\n}\n\n// Using a WeakMap instead of a WeakSet because this one works in IE11 :(\nconst FromIteration = new WeakMap();\n// dynamic children means it was generated by an iteration\n// in a template, and will require a more complex diffing algo.\nfunction markAsDynamicChildren(children) {\n    FromIteration.set(children, 1);\n}\nfunction hasDynamicChildren(children) {\n    return FromIteration.has(children);\n}\nfunction patchChildren(host, shadowRoot, oldCh, newCh, isFallback) {\n    if (oldCh !== newCh) {\n        const parentNode = isFallback ? host : shadowRoot;\n        const fn = hasDynamicChildren(newCh) ? updateDynamicChildren : updateStaticChildren;\n        fn(parentNode, oldCh, newCh);\n    }\n}\nlet TextNodeProto;\n// this method is supposed to be invoked when in fallback mode only\n// to patch text nodes generated by a template.\nfunction patchTextNodeProto(text) {\n    if (isUndefined(TextNodeProto)) {\n        TextNodeProto = PatchedNode(text).prototype;\n    }\n    setPrototypeOf(text, TextNodeProto);\n}\nlet CommentNodeProto;\n// this method is supposed to be invoked when in fallback mode only\n// to patch comment nodes generated by a template.\nfunction patchCommentNodeProto(comment) {\n    if (isUndefined(CommentNodeProto)) {\n        CommentNodeProto = PatchedNode(comment).prototype;\n    }\n    setPrototypeOf(comment, CommentNodeProto);\n}\nconst TagToProtoCache = create(null);\nfunction getPatchedElementClass(elm) {\n    switch (tagNameGetter.call(elm)) {\n        case 'SLOT':\n            return PatchedSlotElement(elm);\n        case 'IFRAME':\n            return PatchedIframeElement(elm);\n    }\n    return PatchedElement(elm);\n}\n// this method is supposed to be invoked when in fallback mode only\n// to patch elements generated by a template.\nfunction patchElementProto(elm, options) {\n    const { sel, isPortal, shadowAttribute } = options;\n    let proto = TagToProtoCache[sel];\n    if (isUndefined(proto)) {\n        proto = TagToProtoCache[sel] = getPatchedElementClass(elm).prototype;\n    }\n    setPrototypeOf(elm, proto);\n    if (isTrue(isPortal)) {\n        markElementAsPortal(elm);\n    }\n    setCSSToken(elm, shadowAttribute);\n}\nfunction patchCustomElementProto(elm, options) {\n    const { def, shadowAttribute } = options;\n    let patchedBridge = def.patchedBridge;\n    if (isUndefined(patchedBridge)) {\n        patchedBridge = def.patchedBridge = PatchedCustomElement(elm);\n    }\n    // temporary patching the proto, eventually this should be just more nodes in the proto chain\n    setPrototypeOf(elm, patchedBridge.prototype);\n    setCSSToken(elm, shadowAttribute);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction getNodeRestrictionsDescriptors(node, options) {\n    if (false) {}\n    // getPropertyDescriptor here recursively looks up the prototype chain\n    // and returns the first descriptor for the property\n    const originalTextContentDescriptor = getPropertyDescriptor(node, 'textContent');\n    const originalNodeValueDescriptor = getPropertyDescriptor(node, 'nodeValue');\n    const { appendChild, insertBefore, removeChild, replaceChild, } = node;\n    return {\n        appendChild: {\n            value(aChild) {\n                if (this instanceof Element && options.isPortal !== true) {\n                    assert.logError(`appendChild is disallowed in Element unless \\`lwc:dom=\"manual\"\\` directive is used in the template.`, this);\n                }\n                return appendChild.call(this, aChild);\n            },\n            enumerable: false,\n            writable: false,\n            configurable: true,\n        },\n        insertBefore: {\n            value(newNode, referenceNode) {\n                if (this instanceof Element && options.isPortal !== true) {\n                    assert.logError(`insertBefore is disallowed in Element unless \\`lwc:dom=\"manual\"\\` directive is used in the template.`, this);\n                }\n                return insertBefore.call(this, newNode, referenceNode);\n            },\n            enumerable: false,\n            writable: false,\n            configurable: true,\n        },\n        removeChild: {\n            value(aChild) {\n                if (this instanceof Element && options.isPortal !== true) {\n                    assert.logError(`removeChild is disallowed in Element unless \\`lwc:dom=\"manual\"\\` directive is used in the template.`, this);\n                }\n                return removeChild.call(this, aChild);\n            },\n            enumerable: false,\n            writable: false,\n            configurable: true,\n        },\n        replaceChild: {\n            value(newChild, oldChild) {\n                if (this instanceof Element && options.isPortal !== true) {\n                    assert.logError(`replaceChild is disallowed in Element unless \\`lwc:dom=\"manual\"\\` directive is used in the template.`, this);\n                }\n                return replaceChild.call(this, newChild, oldChild);\n            },\n            enumerable: false,\n            writable: false,\n            configurable: true,\n        },\n        nodeValue: {\n            get() {\n                return originalNodeValueDescriptor.get.call(this);\n            },\n            set(value) {\n                if (true) {\n                    if (this instanceof Element && options.isPortal !== true) {\n                        assert.logError(`nodeValue is disallowed in Element unless \\`lwc:dom=\"manual\"\\` directive is used in the template.`, this);\n                    }\n                }\n                originalNodeValueDescriptor.set.call(this, value);\n            }\n        },\n        textContent: {\n            get() {\n                return originalTextContentDescriptor.get.call(this);\n            },\n            set(value) {\n                if (true) {\n                    if (this instanceof Element && options.isPortal !== true) {\n                        assert.logError(`textContent is disallowed in Element unless \\`lwc:dom=\"manual\"\\` directive is used in the template.`, this);\n                    }\n                }\n                originalTextContentDescriptor.set.call(this, value);\n            }\n        },\n    };\n}\nfunction getElementRestrictionsDescriptors(elm, options) {\n    if (false) {}\n    const descriptors = getNodeRestrictionsDescriptors(elm, options);\n    const originalInnerHTMLDescriptor = getPropertyDescriptor(elm, 'innerHTML');\n    assign(descriptors, {\n        innerHTML: {\n            get() {\n                return originalInnerHTMLDescriptor.get.call(this);\n            },\n            set(value) {\n                if (true) {\n                    if (options.isPortal !== true) {\n                        assert.logError(`innerHTML is disallowed in Element unless \\`lwc:dom=\"manual\"\\` directive is used in the template.`, this);\n                    }\n                }\n                return originalInnerHTMLDescriptor.set.call(this, value);\n            },\n            enumerable: true,\n            configurable: true,\n        }\n    });\n    return descriptors;\n}\nfunction getShadowRootRestrictionsDescriptors(sr, options) {\n    if (false) {}\n    // blacklisting properties in dev mode only to avoid people doing the wrong\n    // thing when using the real shadow root, because if that's the case,\n    // the component will not work when running in fallback mode.\n    const originalQuerySelector = sr.querySelector;\n    const originalQuerySelectorAll = sr.querySelectorAll;\n    const originalAddEventListener = sr.addEventListener;\n    const descriptors = getNodeRestrictionsDescriptors(sr, options);\n    assign(descriptors, {\n        addEventListener: {\n            value(type) {\n                assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${toString(sr)} by adding an event listener for \"${type}\".`);\n                return originalAddEventListener.apply(this, arguments);\n            }\n        },\n        querySelector: {\n            value() {\n                const vm = getShadowRootVM(this);\n                assert.isFalse(isBeingConstructed(vm), `this.template.querySelector() cannot be called during the construction of the custom element for ${vm} because no content has been rendered yet.`);\n                return originalQuerySelector.apply(this, arguments);\n            }\n        },\n        querySelectorAll: {\n            value() {\n                const vm = getShadowRootVM(this);\n                assert.isFalse(isBeingConstructed(vm), `this.template.querySelectorAll() cannot be called during the construction of the custom element for ${vm} because no content has been rendered yet.`);\n                return originalQuerySelectorAll.apply(this, arguments);\n            }\n        },\n    });\n    const BlackListedShadowRootMethods = {\n        appendChild: 0,\n        removeChild: 0,\n        replaceChild: 0,\n        cloneNode: 0,\n        insertBefore: 0,\n        getElementById: 0,\n        getSelection: 0,\n        elementsFromPoint: 0,\n    };\n    forEach.call(getOwnPropertyNames(BlackListedShadowRootMethods), (methodName) => {\n        const descriptor = {\n            get() {\n                throw new Error(`Disallowed method \"${methodName}\" in ShadowRoot.`);\n            }\n        };\n        descriptors[methodName] = descriptor;\n    });\n    return descriptors;\n}\n// Custom Elements Restrictions:\n// -----------------------------\nfunction getAttributePatched(attrName) {\n    if (true) {\n        const vm = getCustomElementVM(this);\n        assertAttributeReflectionCapability(vm, attrName);\n    }\n    return getAttribute.apply(this, ArraySlice.call(arguments));\n}\nfunction setAttributePatched(attrName, newValue) {\n    const vm = getCustomElementVM(this);\n    if (true) {\n        assertAttributeMutationCapability(vm, attrName);\n        assertAttributeReflectionCapability(vm, attrName);\n    }\n    setAttribute.apply(this, ArraySlice.call(arguments));\n}\nfunction setAttributeNSPatched(attrNameSpace, attrName, newValue) {\n    const vm = getCustomElementVM(this);\n    if (true) {\n        assertAttributeMutationCapability(vm, attrName);\n        assertAttributeReflectionCapability(vm, attrName);\n    }\n    setAttributeNS.apply(this, ArraySlice.call(arguments));\n}\nfunction removeAttributePatched(attrName) {\n    const vm = getCustomElementVM(this);\n    // marking the set is needed for the AOM polyfill\n    if (true) {\n        assertAttributeMutationCapability(vm, attrName);\n        assertAttributeReflectionCapability(vm, attrName);\n    }\n    removeAttribute.apply(this, ArraySlice.call(arguments));\n}\nfunction removeAttributeNSPatched(attrNameSpace, attrName) {\n    const vm = getCustomElementVM(this);\n    if (true) {\n        assertAttributeMutationCapability(vm, attrName);\n        assertAttributeReflectionCapability(vm, attrName);\n    }\n    removeAttributeNS.apply(this, ArraySlice.call(arguments));\n}\nfunction assertAttributeReflectionCapability(vm, attrName) {\n    if (false) {}\n    const propName = isString(attrName) ? getPropNameFromAttrName(StringToLowerCase.call(attrName)) : null;\n    const { elm, def: { props: propsConfig } } = vm;\n    if (!isUndefined(getNodeOwnerKey$1(elm)) && isAttributeLocked(elm, attrName) && propsConfig && propName && propsConfig[propName]) {\n        assert.logError(`Invalid attribute \"${StringToLowerCase.call(attrName)}\" for ${vm}. Instead access the public property with \\`element.${propName};\\`.`, elm);\n    }\n}\nfunction assertAttributeMutationCapability(vm, attrName) {\n    if (false) {}\n    const { elm } = vm;\n    if (!isUndefined(getNodeOwnerKey$1(elm)) && isAttributeLocked(elm, attrName)) {\n        assert.logError(`Invalid operation on Element ${vm}. Elements created via a template should not be mutated using DOM APIs. Instead of attempting to update this element directly to change the value of attribute \"${attrName}\", you can update the state of the component, and let the engine to rehydrate the element accordingly.`, elm);\n    }\n}\nfunction getCustomElementRestrictionsDescriptors(elm, options) {\n    if (false) {}\n    const descriptors = getNodeRestrictionsDescriptors(elm, options);\n    const originalAddEventListener = elm.addEventListener;\n    return assign(descriptors, {\n        addEventListener: {\n            value(type) {\n                assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${toString(elm)} by adding an event listener for \"${type}\".`);\n                return originalAddEventListener.apply(this, arguments);\n            }\n        },\n        // replacing mutators and accessors on the element itself to catch any mutation\n        getAttribute: {\n            value: getAttributePatched,\n            configurable: true,\n        },\n        setAttribute: {\n            value: setAttributePatched,\n            configurable: true,\n        },\n        setAttributeNS: {\n            value: setAttributeNSPatched,\n            configurable: true,\n        },\n        removeAttribute: {\n            value: removeAttributePatched,\n            configurable: true,\n        },\n        removeAttributeNS: {\n            value: removeAttributeNSPatched,\n            configurable: true,\n        },\n    });\n}\nfunction getComponentRestrictionsDescriptors(cmp, options) {\n    if (false) {}\n    const originalSetAttribute = cmp.setAttribute;\n    return {\n        setAttribute: {\n            value(attrName, value) {\n                // logging errors for experimental and special attributes\n                if (isString(attrName)) {\n                    const propName = getPropNameFromAttrName(attrName);\n                    const info = getGlobalHTMLPropertiesInfo();\n                    if (info[propName] && info[propName].attribute) {\n                        const { error, experimental } = info[propName];\n                        if (error) {\n                            assert.logError(error, getComponentVM(this).elm);\n                        }\n                        else if (experimental) {\n                            assert.logError(`Attribute \\`${attrName}\\` is an experimental attribute that is not standardized or supported by all browsers. Property \"${propName}\" and attribute \"${attrName}\" are ignored.`, getComponentVM(this).elm);\n                        }\n                    }\n                }\n                originalSetAttribute.apply(this, arguments);\n            },\n            enumerable: true,\n            configurable: true,\n            writable: true,\n        },\n        tagName: {\n            get() {\n                throw new Error(`Usage of property \\`tagName\\` is disallowed because the component itself does not know which tagName will be used to create the element, therefore writing code that check for that value is error prone.`);\n            },\n            enumerable: true,\n            configurable: true,\n        },\n    };\n}\nfunction getLightingElementProtypeRestrictionsDescriptors(proto, options) {\n    if (false) {}\n    const info = getGlobalHTMLPropertiesInfo();\n    const descriptors = {};\n    forEach.call(getOwnPropertyNames(info), (propName) => {\n        if (propName in proto) {\n            return; // no need to redefine something that we are already exposing\n        }\n        descriptors[propName] = {\n            get() {\n                const { error, attribute, readOnly, experimental } = info[propName];\n                const msg = [];\n                msg.push(`Accessing the global HTML property \"${propName}\" in ${this} is disabled.`);\n                if (error) {\n                    msg.push(error);\n                }\n                else {\n                    if (experimental) {\n                        msg.push(`This is an experimental property that is not standardized or supported by all browsers. Property \"${propName}\" and attribute \"${attribute}\" are ignored.`);\n                    }\n                    if (readOnly) {\n                        // TODO - need to improve this message\n                        msg.push(`Property is read-only.`);\n                    }\n                    if (attribute) {\n                        msg.push(`\"Instead access it via the reflective attribute \"${attribute}\" with one of these techniques:`);\n                        msg.push(`  * Use \\`this.getAttribute(\"${attribute}\")\\` to access the attribute value. This option is best suited for accessing the value in a getter during the rendering process.`);\n                        msg.push(`  * Declare \\`static observedAttributes = [\"${attribute}\"]\\` and use \\`attributeChangedCallback(attrName, oldValue, newValue)\\` to get a notification each time the attribute changes. This option is best suited for reactive programming, eg. fetching new data each time the attribute is updated.`);\n                    }\n                }\n                assert.logWarning(msg.join('\\n'), getComponentVM(this).elm);\n                return; // explicit undefined\n            },\n            // a setter is required here to avoid TypeError's when an attribute is set in a template but only the above getter is defined\n            set() { },\n        };\n    });\n    return descriptors;\n}\nfunction patchElementWithRestrictions(elm, options) {\n    defineProperties(elm, getElementRestrictionsDescriptors(elm, options));\n}\n// This routine will prevent access to certain properties on a shadow root instance to guarantee\n// that all components will work fine in IE11 and other browsers without shadow dom support.\nfunction patchShadowRootWithRestrictions(sr, options) {\n    defineProperties(sr, getShadowRootRestrictionsDescriptors(sr, options));\n}\nfunction patchCustomElementWithRestrictions(elm, options) {\n    const restrictionsDescriptors = getCustomElementRestrictionsDescriptors(elm, options);\n    const elmProto = getPrototypeOf(elm);\n    setPrototypeOf(elm, create(elmProto, restrictionsDescriptors));\n}\nfunction patchComponentWithRestrictions(cmp, options) {\n    defineProperties(cmp, getComponentRestrictionsDescriptors(cmp, options));\n}\nfunction patchLightningElementPrototypeWithRestrictions(proto, options) {\n    defineProperties(proto, getLightingElementProtypeRestrictionsDescriptors(proto, options));\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction updateNodeHook(oldVnode, vnode) {\n    if (oldVnode.text !== vnode.text) {\n        nodeValueSetter.call(vnode.elm, vnode.text);\n    }\n}\nfunction insertNodeHook(vnode, parentNode, referenceNode) {\n    insertBefore.call(parentNode, vnode.elm, referenceNode);\n}\nfunction removeNodeHook(vnode, parentNode) {\n    removeChild.call(parentNode, vnode.elm);\n}\nfunction createTextHook(vnode) {\n    const text = vnode.elm;\n    setNodeOwnerKey$1(text, vnode.uid);\n    if (isTrue(vnode.fallback)) {\n        patchTextNodeProto(text);\n    }\n}\nfunction createCommentHook(vnode) {\n    const comment = vnode.elm;\n    setNodeOwnerKey$1(comment, vnode.uid);\n    if (isTrue(vnode.fallback)) {\n        patchCommentNodeProto(comment);\n    }\n}\nfunction createElmDefaultHook(vnode) {\n    modEvents.create(vnode);\n    // Attrs need to be applied to element before props\n    // IE11 will wipe out value on radio inputs if value\n    // is set before type=radio.\n    modAttrs.create(vnode);\n    modProps.create(vnode);\n    modStaticClassName.create(vnode);\n    modStaticStyle.create(vnode);\n    modComputedClassName.create(vnode);\n    modComputedStyle.create(vnode);\n    contextModule.create(vnode);\n}\nvar LWCDOMMode;\n(function (LWCDOMMode) {\n    LWCDOMMode[\"manual\"] = \"manual\";\n})(LWCDOMMode || (LWCDOMMode = {}));\nfunction createElmHook(vnode) {\n    const { uid, sel, fallback } = vnode;\n    const elm = vnode.elm;\n    setNodeOwnerKey$1(elm, uid);\n    if (isTrue(fallback)) {\n        const { shadowAttribute, data: { context } } = vnode;\n        const isPortal = !isUndefined(context) && !isUndefined(context.lwc) && context.lwc.dom === LWCDOMMode.manual;\n        patchElementProto(elm, {\n            sel,\n            isPortal,\n            shadowAttribute,\n        });\n    }\n    if (true) {\n        const { data: { context } } = vnode;\n        const isPortal = !isUndefined(context) && !isUndefined(context.lwc) && context.lwc.dom === LWCDOMMode.manual;\n        patchElementWithRestrictions(elm, { isPortal });\n    }\n}\nfunction updateElmDefaultHook(oldVnode, vnode) {\n    // Attrs need to be applied to element before props\n    // IE11 will wipe out value on radio inputs if value\n    // is set before type=radio.\n    modAttrs.update(oldVnode, vnode);\n    modProps.update(oldVnode, vnode);\n    modComputedClassName.update(oldVnode, vnode);\n    modComputedStyle.update(oldVnode, vnode);\n}\nfunction insertCustomElmHook(vnode) {\n    const vm = getCustomElementVM(vnode.elm);\n    appendVM(vm);\n    renderVM(vm);\n}\nfunction updateChildrenHook(oldVnode, vnode) {\n    const { children } = vnode;\n    const fn = hasDynamicChildren(children) ? updateDynamicChildren : updateStaticChildren;\n    fn(vnode.elm, oldVnode.children, children);\n}\nfunction allocateChildrenHook(vnode) {\n    if (isTrue(vnode.fallback)) {\n        // slow path\n        const elm = vnode.elm;\n        const vm = getCustomElementVM(elm);\n        const children = vnode.children;\n        allocateInSlot(vm, children);\n        // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!\n        vnode.children = EmptyArray;\n    }\n}\nfunction createCustomElmHook(vnode) {\n    const elm = vnode.elm;\n    if (hasOwnProperty.call(elm, ViewModelReflection)) {\n        // There is a possibility that a custom element is registered under tagName,\n        // in which case, the initialization is already carry on, and there is nothing else\n        // to do here since this hook is called right after invoking `document.createElement`.\n        return;\n    }\n    const { mode, ctor, uid, fallback } = vnode;\n    setNodeOwnerKey$1(elm, uid);\n    const def = getComponentDef(ctor);\n    setElementProto(elm, def);\n    if (isTrue(fallback)) {\n        const { shadowAttribute } = vnode;\n        patchCustomElementProto(elm, {\n            def,\n            shadowAttribute,\n        });\n    }\n    createVM(vnode.sel, elm, ctor, {\n        mode,\n        fallback,\n    });\n    const vm = getCustomElementVM(elm);\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        assert.isTrue(isArray(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n    }\n    if (true) {\n        patchCustomElementWithRestrictions(elm, EmptyObject);\n    }\n}\nfunction createCustomElmDefaultHook(vnode) {\n    modEvents.create(vnode);\n    // Attrs need to be applied to element before props\n    // IE11 will wipe out value on radio inputs if value\n    // is set before type=radio.\n    modAttrs.create(vnode);\n    modProps.create(vnode);\n    modStaticClassName.create(vnode);\n    modStaticStyle.create(vnode);\n    modComputedClassName.create(vnode);\n    modComputedStyle.create(vnode);\n    contextModule.create(vnode);\n}\nfunction createChildrenHook(vnode) {\n    const { elm, children } = vnode;\n    for (let j = 0; j < children.length; ++j) {\n        const ch = children[j];\n        if (ch != null) {\n            ch.hook.create(ch);\n            ch.hook.insert(ch, elm, null);\n        }\n    }\n}\nfunction renderCustomElmHook(vnode) {\n    const vm = getCustomElementVM(vnode.elm);\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        assert.isTrue(isArray(vnode.children), `Invalid vnode for a custom element, it must have children defined.`);\n    }\n    renderVM(vm);\n}\nfunction updateCustomElmDefaultHook(oldVnode, vnode) {\n    // Attrs need to be applied to element before props\n    // IE11 will wipe out value on radio inputs if value\n    // is set before type=radio.\n    modAttrs.update(oldVnode, vnode);\n    modProps.update(oldVnode, vnode);\n    modComputedClassName.update(oldVnode, vnode);\n    modComputedStyle.update(oldVnode, vnode);\n}\nfunction removeElmHook(vnode) {\n    vnode.hook.destroy(vnode);\n}\nfunction destroyCustomElmHook(vnode) {\n    removeVM(getCustomElementVM(vnode.elm));\n}\nfunction destroyElmHook(vnode) {\n    const { children } = vnode;\n    for (let j = 0, len = children.length; j < len; ++j) {\n        const ch = children[j];\n        if (ch != null) {\n            ch.hook.destroy(ch);\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst Services = create(null);\nconst hooks = ['wiring', 'locator', 'rendered', 'connected', 'disconnected'];\nfunction register(service) {\n    if (true) {\n        assert.isTrue(isObject(service), `Invalid service declaration, ${service}: service must be an object`);\n    }\n    for (let i = 0; i < hooks.length; ++i) {\n        const hookName = hooks[i];\n        if (hookName in service) {\n            let l = Services[hookName];\n            if (isUndefined(l)) {\n                Services[hookName] = l = [];\n            }\n            ArrayPush.call(l, service[hookName]);\n        }\n    }\n}\nfunction invokeServiceHook(vm, cbs) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        assert.isTrue(isArray(cbs) && cbs.length > 0, `Optimize invokeServiceHook() to be invoked only when needed`);\n    }\n    const { component, data, def, context } = vm;\n    for (let i = 0, len = cbs.length; i < len; ++i) {\n        cbs[i].call(undefined, component, data, def, context);\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { createElement: createElement$1, createElementNS: createElementNS$1, createTextNode: createTextNode$1, createComment: createComment$1, } = document;\nconst CHAR_S = 115;\nconst CHAR_V = 118;\nconst CHAR_G = 103;\nconst NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';\nconst SymbolIterator = Symbol.iterator;\nfunction noop() { }\nconst TextHook = {\n    create: (vnode) => {\n        if (isUndefined(vnode.elm)) {\n            // supporting the ability to inject an element via a vnode\n            // this is used mostly for caching in compiler\n            vnode.elm = createTextNode$1.call(document, vnode.text);\n        }\n        createTextHook(vnode);\n    },\n    update: updateNodeHook,\n    insert: insertNodeHook,\n    move: insertNodeHook,\n    remove: removeNodeHook,\n    destroy: noop,\n};\nconst CommentHook = {\n    create: (vnode) => {\n        if (isUndefined(vnode.elm)) {\n            // supporting the ability to inject an element via a vnode\n            // this is used mostly for caching in compiler\n            vnode.elm = createComment$1.call(document, vnode.text);\n        }\n        createCommentHook(vnode);\n    },\n    update: updateNodeHook,\n    insert: insertNodeHook,\n    move: insertNodeHook,\n    remove: removeNodeHook,\n    destroy: noop,\n};\n// insert is called after update, which is used somewhere else (via a module)\n// to mark the vm as inserted, that means we cannot use update as the main channel\n// to rehydrate when dirty, because sometimes the element is not inserted just yet,\n// which breaks some invariants. For that reason, we have the following for any\n// Custom Element that is inserted via a template.\nconst ElementHook = {\n    create: (vnode) => {\n        const { data, sel, elm } = vnode;\n        const { ns, create: create$$1 } = data;\n        if (isUndefined(elm)) {\n            // supporting the ability to inject an element via a vnode\n            // this is used mostly for caching in compiler and style tags\n            vnode.elm = isUndefined(ns)\n                ? createElement$1.call(document, sel)\n                : createElementNS$1.call(document, ns, sel);\n        }\n        createElmHook(vnode);\n        create$$1(vnode);\n    },\n    update: (oldVnode, vnode) => {\n        const { data: { update } } = vnode;\n        update(oldVnode, vnode);\n        updateChildrenHook(oldVnode, vnode);\n    },\n    insert: (vnode, parentNode, referenceNode) => {\n        insertBefore.call(parentNode, vnode.elm, referenceNode);\n        createChildrenHook(vnode);\n    },\n    move: (vnode, parentNode, referenceNode) => {\n        insertBefore.call(parentNode, vnode.elm, referenceNode);\n    },\n    remove: (vnode, parentNode) => {\n        removeChild.call(parentNode, vnode.elm);\n        removeElmHook(vnode);\n    },\n    destroy: destroyElmHook,\n};\nconst CustomElementHook = {\n    create: (vnode) => {\n        const { sel, data: { create: create$$1 }, elm } = vnode;\n        if (isUndefined(elm)) {\n            // supporting the ability to inject an element via a vnode\n            // this is used mostly for caching in compiler and style tags\n            vnode.elm = createElement$1.call(document, sel);\n        }\n        createCustomElmHook(vnode);\n        allocateChildrenHook(vnode);\n        create$$1(vnode);\n    },\n    update: (oldVnode, vnode) => {\n        const { data: { update } } = vnode;\n        update(oldVnode, vnode);\n        // in fallback mode, the allocation will always the children to\n        // empty and delegate the real allocation to the slot elements\n        allocateChildrenHook(vnode);\n        // in fallback mode, the children will be always empty, so, nothing\n        // will happen, but in native, it does allocate the light dom\n        updateChildrenHook(oldVnode, vnode);\n        // this will update the shadowRoot\n        renderCustomElmHook(vnode);\n    },\n    insert: (vnode, parentNode, referenceNode) => {\n        insertBefore.call(parentNode, vnode.elm, referenceNode);\n        createChildrenHook(vnode);\n        insertCustomElmHook(vnode);\n    },\n    move: (vnode, parentNode, referenceNode) => {\n        insertBefore.call(parentNode, vnode.elm, referenceNode);\n    },\n    remove: (vnode, parentNode) => {\n        removeChild.call(parentNode, vnode.elm);\n        removeElmHook(vnode);\n    },\n    destroy: (vnode) => {\n        destroyCustomElmHook(vnode);\n        destroyElmHook(vnode);\n    },\n};\n// TODO: this should be done by the compiler, adding ns to every sub-element\nfunction addNS(vnode) {\n    const { data, children, sel } = vnode;\n    // TODO: review why `sel` equal `foreignObject` should get this `ns`\n    data.ns = NamespaceAttributeForSVG;\n    if (isArray(children) && sel !== 'foreignObject') {\n        for (let j = 0, n = children.length; j < n; ++j) {\n            const childNode = children[j];\n            if (childNode != null && childNode.hook === ElementHook) {\n                addNS(childNode);\n            }\n        }\n    }\n}\nfunction getCurrentOwnerId() {\n    if (true) {\n        // TODO: enable this after refactoring all failing tests\n        if (isNull(vmBeingRendered)) {\n            return 0;\n        }\n        // assert.invariant(!isNull(vmBeingRendered), `Invalid invocation of getCurrentOwnerId().`);\n    }\n    return vmBeingRendered.uid;\n}\nconst getCurrentFallback = isNativeShadowRootAvailable ?\n    function () {\n        if (true) ;\n        return vmBeingRendered.fallback;\n    } : () => {\n    if (true) ;\n    return true;\n};\nfunction getCurrentShadowAttribute() {\n    if (true) {\n        // TODO: enable this after refactoring all failing tests\n        if (isNull(vmBeingRendered)) {\n            return;\n        }\n        // assert.invariant(!isNull(vmBeingRendered), `Invalid invocation of getCurrentShadowToken().`);\n    }\n    // TODO: remove this condition after refactoring all failing tests\n    return vmBeingRendered.context.shadowAttribute;\n}\n// [h]tml node\nfunction h(sel, data, children) {\n    if (true) {\n        assert.isTrue(isString(sel), `h() 1st argument sel must be a string.`);\n        assert.isTrue(isObject(data), `h() 2nd argument data must be an object.`);\n        assert.isTrue(isArray(children), `h() 3rd argument children must be an array.`);\n        assert.isTrue(\"key\" in data, ` <${sel}> \"key\" attribute is invalid or missing for ${vmBeingRendered}. Key inside iterator is either undefined or null.`);\n        // checking reserved internal data properties\n        assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n        assert.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);\n        if (data.style && !isString(data.style)) {\n            assert.logWarning(`Invalid 'style' attribute passed to <${sel}> should be a string value, and will be ignored.`, vmBeingRendered.elm);\n        }\n        forEach.call(children, (childVnode) => {\n            if (childVnode != null) {\n                assert.isTrue(childVnode && \"sel\" in childVnode && \"data\" in childVnode && \"children\" in childVnode && \"text\" in childVnode && \"elm\" in childVnode && \"key\" in childVnode, `${childVnode} is not a vnode.`);\n            }\n        });\n    }\n    const { key } = data;\n    if (isUndefined(data.create)) {\n        data.create = createElmDefaultHook;\n    }\n    if (isUndefined(data.update)) {\n        data.update = updateElmDefaultHook;\n    }\n    let text, elm, shadowAttribute; // tslint:disable-line\n    const fallback = getCurrentFallback();\n    // shadowAttribute is only really needed in fallback mode\n    if (fallback) {\n        shadowAttribute = getCurrentShadowAttribute();\n    }\n    const uid = getCurrentOwnerId();\n    const vnode = {\n        sel,\n        data,\n        children,\n        text,\n        elm,\n        key,\n        hook: ElementHook,\n        shadowAttribute,\n        uid,\n        fallback,\n    };\n    if (sel.length === 3 && StringCharCodeAt.call(sel, 0) === CHAR_S && StringCharCodeAt.call(sel, 1) === CHAR_V && StringCharCodeAt.call(sel, 2) === CHAR_G) {\n        addNS(vnode);\n    }\n    return vnode;\n}\n// [t]ab[i]ndex function\nfunction ti(value) {\n    // if value is greater than 0, we normalize to 0\n    // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through\n    // If value is less than -1, we don't care\n    const shouldNormalize = (value > 0 && !(isTrue(value) || isFalse(value)));\n    if (true) {\n        if (shouldNormalize) {\n            assert.logWarning(`Invalid tabindex value \\`${toString(value)}\\` in template for ${vmBeingRendered}. This attribute can only be set to 0 or -1.`, vmBeingRendered.elm);\n        }\n    }\n    return shouldNormalize ? 0 : value;\n}\n// [s]lot element node\nfunction s(slotName, data, children, slotset) {\n    if (true) {\n        assert.isTrue(isString(slotName), `s() 1st argument slotName must be a string.`);\n        assert.isTrue(isObject(data), `s() 2nd argument data must be an object.`);\n        assert.isTrue(isArray(children), `h() 3rd argument children must be an array.`);\n    }\n    if (!isUndefined(slotset) && !isUndefined(slotset[slotName]) && slotset[slotName].length !== 0) {\n        children = slotset[slotName];\n    }\n    const vnode = h('slot', data, children);\n    if (isTrue(vnode.fallback)) {\n        markAsDynamicChildren(children);\n    }\n    return vnode;\n}\n// [c]ustom element node\nfunction c(sel, Ctor, data, children) {\n    if (isCircularModuleDependency(Ctor)) {\n        Ctor = resolveCircularModuleDependency(Ctor);\n    }\n    if (true) {\n        assert.isTrue(isString(sel), `c() 1st argument sel must be a string.`);\n        assert.isTrue(isFunction(Ctor), `c() 2nd argument Ctor must be a function.`);\n        assert.isTrue(isObject(data), `c() 3nd argument data must be an object.`);\n        assert.isTrue(arguments.length === 3 || isArray(children), `c() 4nd argument data must be an array.`);\n        // TODO: enable this once all tests are changed to use compileTemplate utility\n        // assert.isTrue(\"key\" in compilerData, ` <${sel}> \"key\" attribute is invalid or missing for ${vmBeingRendered}. Key inside iterator is either undefined or null.`);\n        // checking reserved internal data properties\n        assert.isFalse(data.className && data.classMap, `vnode.data.className and vnode.data.classMap ambiguous declaration.`);\n        assert.isFalse(data.styleMap && data.style, `vnode.data.styleMap and vnode.data.style ambiguous declaration.`);\n        if (data.style && !isString(data.style)) {\n            assert.logWarning(`Invalid 'style' attribute passed to <${sel}> should be a string value, and will be ignored.`, vmBeingRendered.elm);\n        }\n        if (arguments.length === 4) {\n            forEach.call(children, (childVnode) => {\n                if (childVnode != null) {\n                    assert.isTrue(childVnode && \"sel\" in childVnode && \"data\" in childVnode && \"children\" in childVnode && \"text\" in childVnode && \"elm\" in childVnode && \"key\" in childVnode, `${childVnode} is not a vnode.`);\n                }\n            });\n        }\n    }\n    const { key } = data;\n    if (isUndefined(data.create)) {\n        data.create = createCustomElmDefaultHook;\n    }\n    if (isUndefined(data.update)) {\n        data.update = updateCustomElmDefaultHook;\n    }\n    let text, elm, shadowAttribute; // tslint:disable-line\n    const fallback = getCurrentFallback();\n    // shadowAttribute is only really needed in fallback mode\n    if (fallback) {\n        shadowAttribute = getCurrentShadowAttribute();\n    }\n    const uid = getCurrentOwnerId();\n    children = arguments.length === 3 ? EmptyArray : children;\n    const vnode = {\n        sel,\n        data,\n        children,\n        text,\n        elm,\n        key,\n        hook: CustomElementHook,\n        ctor: Ctor,\n        shadowAttribute,\n        uid,\n        fallback,\n        mode: 'open',\n    };\n    return vnode;\n}\n// [i]terable node\nfunction i(iterable, factory) {\n    const list = [];\n    // marking the list as generated from iteration so we can optimize the diffing\n    markAsDynamicChildren(list);\n    if (isUndefined(iterable) || iterable === null) {\n        if (true) {\n            assert.logWarning(`Invalid template iteration for value \"${iterable}\" in ${vmBeingRendered}, it should be an Array or an iterable Object.`, vmBeingRendered.elm);\n        }\n        return list;\n    }\n    if (true) {\n        assert.isFalse(isUndefined(iterable[SymbolIterator]), `Invalid template iteration for value \\`${iterable}\\` in ${vmBeingRendered}, it requires an array-like object, not \\`null\\` or \\`undefined\\`.`);\n    }\n    const iterator = iterable[SymbolIterator]();\n    if (true) {\n        assert.isTrue(iterator && isFunction(iterator.next), `Invalid iterator function for \"${iterable}\" in ${vmBeingRendered}.`);\n    }\n    let next = iterator.next();\n    let j = 0;\n    let { value, done: last } = next;\n    let keyMap;\n    let iterationError;\n    if (true) {\n        keyMap = create(null);\n    }\n    while (last === false) {\n        // implementing a look-back-approach because we need to know if the element is the last\n        next = iterator.next();\n        last = next.done;\n        // template factory logic based on the previous collected value\n        const vnode = factory(value, j, j === 0, last);\n        if (isArray(vnode)) {\n            ArrayPush.apply(list, vnode);\n        }\n        else {\n            ArrayPush.call(list, vnode);\n        }\n        if (true) {\n            const vnodes = isArray(vnode) ? vnode : [vnode];\n            forEach.call(vnodes, (childVnode) => {\n                if (!isNull(childVnode) && isObject(childVnode) && !isUndefined(childVnode.sel)) {\n                    const { key } = childVnode;\n                    if (isString(key) || isNumber(key)) {\n                        if (keyMap[key] === 1 && isUndefined(iterationError)) {\n                            iterationError = `Duplicated \"key\" attribute value for \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. Key with value \"${childVnode.key}\" appears more than once in iteration. Key values must be unique numbers or strings.`;\n                        }\n                        keyMap[key] = 1;\n                    }\n                    else if (isUndefined(iterationError)) {\n                        iterationError = `Invalid \"key\" attribute value in \"<${childVnode.sel}>\" in ${vmBeingRendered} for item number ${j}. Instead set a unique \"key\" attribute value on all iteration children so internal state can be preserved during rehydration.`;\n                    }\n                }\n            });\n        }\n        // preparing next value\n        j += 1;\n        value = next.value;\n    }\n    if (true) {\n        if (!isUndefined(iterationError)) {\n            assert.logError(iterationError, vmBeingRendered.elm);\n        }\n    }\n    return list;\n}\n/**\n * [f]lattening\n */\nfunction f(items) {\n    if (true) {\n        assert.isTrue(isArray(items), 'flattening api can only work with arrays.');\n    }\n    const len = items.length;\n    const flattened = [];\n    // all flattened nodes should be marked as dynamic because\n    // flattened nodes are because of a conditional or iteration.\n    // We have to mark as dynamic because this could switch from an\n    // iterator to \"static\" text at any time.\n    // TODO: compiler should give us some sort of indicator\n    // to describe whether a vnode is dynamic or not\n    markAsDynamicChildren(flattened);\n    for (let j = 0; j < len; j += 1) {\n        const item = items[j];\n        if (isArray(item)) {\n            ArrayPush.apply(flattened, item);\n        }\n        else {\n            ArrayPush.call(flattened, item);\n        }\n    }\n    return flattened;\n}\n// [t]ext node\nfunction t(text) {\n    const data = EmptyObject;\n    let sel, children, key, elm; // tslint:disable-line\n    return {\n        sel,\n        data,\n        children,\n        text,\n        elm,\n        key,\n        hook: TextHook,\n        uid: getCurrentOwnerId(),\n        fallback: getCurrentFallback(),\n    };\n}\n// comment node\nfunction p(text) {\n    const data = EmptyObject;\n    let sel = '!', children, key, elm; // tslint:disable-line\n    return {\n        sel,\n        data,\n        children,\n        text,\n        elm,\n        key,\n        hook: CommentHook,\n        uid: getCurrentOwnerId(),\n        fallback: getCurrentFallback(),\n    };\n}\n// [d]ynamic value to produce a text vnode\nfunction d(value) {\n    if (value == null) {\n        return null;\n    }\n    return t(value);\n}\n// [b]ind function\nfunction b(fn) {\n    if (isNull(vmBeingRendered)) {\n        throw new Error();\n    }\n    const vm = vmBeingRendered;\n    return function (event) {\n        if (vm.fallback) {\n            patchEvent(event);\n        }\n        invokeEventListener(vm, fn, vm.component, event);\n    };\n}\n// [f]unction_[b]ind\nfunction fb(fn) {\n    if (isNull(vmBeingRendered)) {\n        throw new Error();\n    }\n    const vm = vmBeingRendered;\n    return function () {\n        return invokeComponentCallback(vm, fn, ArraySlice.call(arguments));\n    };\n}\n// [l]ocator_[l]istener function\nfunction ll(originalHandler, id, context) {\n    if (isNull(vmBeingRendered)) {\n        throw new Error();\n    }\n    const vm = vmBeingRendered;\n    // bind the original handler with b() so we can call it\n    // after resolving the locator\n    const eventListener = b(originalHandler);\n    // create a wrapping handler to resolve locator, and\n    // then invoke the original handler.\n    return function (event) {\n        // located service for the locator metadata\n        const { context: { locator } } = vm;\n        if (!isUndefined(locator)) {\n            const { locator: locatorService } = Services;\n            if (locatorService) {\n                locator.resolved = {\n                    target: id,\n                    host: locator.id,\n                    targetContext: isFunction(context) && context(),\n                    hostContext: isFunction(locator.context) && locator.context()\n                };\n                // a registered `locator` service will be invoked with\n                // access to the context.locator.resolved, which will contain:\n                // outer id, outer context, inner id, and inner context\n                invokeServiceHook(vm, locatorService);\n            }\n        }\n        // invoke original event listener via b()\n        eventListener(event);\n    };\n}\n// [k]ey function\nfunction k(compilerKey, obj) {\n    switch (typeof obj) {\n        case 'number':\n        // TODO: when obj is a numeric key, we might be able to use some\n        // other strategy to combine two numbers into a new unique number\n        case 'string':\n            return compilerKey + ':' + obj;\n        case 'object':\n            if (true) {\n                assert.fail(`Invalid key value \"${obj}\" in ${vmBeingRendered}. Key must be a string or number.`);\n            }\n    }\n}\n// [g]lobal [id] function\nfunction gid(id) {\n    if (isUndefined(id) || id === '') {\n        if (true) {\n            assert.logError(`Invalid id value \"${id}\". Expected a non-empty string.`, vmBeingRendered.elm);\n        }\n        return id;\n    }\n    return isNull(id) ? id : `${id}-${getCurrentOwnerId()}`;\n}\n\nvar api$1 = /*#__PURE__*/Object.freeze({\n    h: h,\n    ti: ti,\n    s: s,\n    c: c,\n    i: i,\n    f: f,\n    t: t,\n    p: p,\n    d: d,\n    b: b,\n    fb: fb,\n    ll: ll,\n    k: k,\n    gid: gid\n});\n\nconst signedTemplateSet = new Set();\nfunction defaultEmptyTemplate() {\n    return [];\n}\nsignedTemplateSet.add(defaultEmptyTemplate);\nfunction isTemplateRegistered(tpl) {\n    return signedTemplateSet.has(tpl);\n}\n// chaining this method as a way to wrap existing\n// assignment of templates easily, without too much transformation\nfunction registerTemplate(tpl) {\n    signedTemplateSet.add(tpl);\n    return tpl;\n}\n// locker-service patches this function during runtime to sanitize vulnerable attributes.\n// when ran off-core this function becomes a noop and returns the user authored value.\nfunction sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {\n    return attrValue;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CachedStyleFragments = create(null);\nfunction createStyleElement(styleContent) {\n    const elm = createElement.call(document, 'style');\n    elm.type = 'text/css';\n    elm.textContent = styleContent;\n    return elm;\n}\nfunction getCachedStyleElement(styleContent) {\n    let fragment = CachedStyleFragments[styleContent];\n    if (isUndefined(fragment)) {\n        fragment = createDocumentFragment.call(document);\n        const elm = createStyleElement(styleContent);\n        appendChild.call(fragment, elm);\n        CachedStyleFragments[styleContent] = fragment;\n    }\n    return fragment.cloneNode(true).firstChild;\n}\nconst globalStyleParent = document.head || document.body || document;\nconst InsertedGlobalStyleContent = create(null);\nfunction insertGlobalStyle(styleContent) {\n    // inserts the global style when needed, otherwise does nothing\n    if (isUndefined(InsertedGlobalStyleContent[styleContent])) {\n        InsertedGlobalStyleContent[styleContent] = true;\n        const elm = createStyleElement(styleContent);\n        appendChild.call(globalStyleParent, elm);\n    }\n}\nfunction noop$1() {\n    /** do nothing */\n}\nfunction createStyleVNode(elm) {\n    const vnode = h('style', {\n        key: 'style',\n        create: noop$1,\n        update: noop$1,\n    }, EmptyArray);\n    // Force the diffing algo to use the cloned style.\n    vnode.elm = elm;\n    return vnode;\n}\n/**\n * Reset the styling token applied to the host element.\n */\nfunction resetStyleAttributes(vm) {\n    const { context, elm } = vm;\n    // Remove the style attribute currently applied to the host element.\n    const oldHostAttribute = context.hostAttribute;\n    if (!isUndefined(oldHostAttribute)) {\n        removeAttribute.call(elm, oldHostAttribute);\n    }\n    // Reset the scoping attributes associated to the context.\n    context.hostAttribute = context.shadowAttribute = undefined;\n}\n/**\n * Apply/Update the styling token applied to the host element.\n */\nfunction applyStyleAttributes(vm, hostAttribute, shadowAttribute) {\n    const { context, elm } = vm;\n    // Remove the style attribute currently applied to the host element.\n    setAttribute.call(elm, hostAttribute, '');\n    context.hostAttribute = hostAttribute;\n    context.shadowAttribute = shadowAttribute;\n}\nfunction evaluateCSS(vm, stylesheets, hostAttribute, shadowAttribute) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        assert.isTrue(isArray(stylesheets), `Invalid stylesheets.`);\n    }\n    const { fallback } = vm;\n    if (fallback) {\n        const hostSelector = `[${hostAttribute}]`;\n        const shadowSelector = `[${shadowAttribute}]`;\n        return forEach.call(stylesheets, stylesheet => {\n            const textContent = stylesheet(hostSelector, shadowSelector, false);\n            insertGlobalStyle(textContent);\n        });\n    }\n    else {\n        // Native shadow in place, we need to act accordingly by using the `:host` selector, and an\n        // empty shadow selector since it is not really needed.\n        const textContent = ArrayReduce.call(stylesheets, (buffer, stylesheet) => {\n            return buffer + stylesheet(emptyString, emptyString, true);\n        }, '');\n        return createStyleVNode(getCachedStyleElement(textContent));\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst EmptySlots = create(null);\nfunction validateSlots(vm, html) {\n    if (false) {}\n    const { cmpSlots = EmptySlots } = vm;\n    const { slots = EmptyArray } = html;\n    for (const slotName in cmpSlots) {\n        // tslint:disable-next-line no-production-assert\n        assert.isTrue(isArray(cmpSlots[slotName]), `Slots can only be set to an array, instead received ${toString(cmpSlots[slotName])} for slot \"${slotName}\" in ${vm}.`);\n        if (ArrayIndexOf.call(slots, slotName) === -1) {\n            // TODO: this should never really happen because the compiler should always validate\n            // tslint:disable-next-line no-production-assert\n            assert.logWarning(`Ignoring unknown provided slot name \"${slotName}\" in ${vm}. This is probably a typo on the slot attribute.`, vm.elm);\n        }\n    }\n}\nfunction validateFields(vm, html) {\n    if (false) {}\n    const component = vm.component;\n    // validating identifiers used by template that should be provided by the component\n    const { ids = [] } = html;\n    forEach.call(ids, (propName) => {\n        if (!(propName in component)) {\n            // tslint:disable-next-line no-production-assert\n            assert.logWarning(`The template rendered by ${vm} references \\`this.${propName}\\`, which is not declared. This is likely a typo in the template.`, vm.elm);\n        }\n        else if (hasOwnProperty.call(component, propName)) {\n            // tslint:disable-next-line no-production-assert\n            assert.fail(`${component}'s template is accessing \\`this.${toString(propName)}\\`, which is considered a non-reactive private field. Instead access it via a getter or make it reactive by decorating it with \\`@track ${toString(propName)}\\`.`);\n        }\n    });\n}\nfunction evaluateTemplate(vm, html) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        assert.isTrue(isFunction(html), `evaluateTemplate() second argument must be an imported template instead of ${toString(html)}`);\n    }\n    // TODO: add identity to the html functions\n    const { component, context, cmpSlots, cmpTemplate } = vm;\n    // reset the cache memoizer for template when needed\n    if (html !== cmpTemplate) {\n        // It is important to reset the content to avoid reusing similar elements generated from a different\n        // template, because they could have similar IDs, and snabbdom just rely on the IDs.\n        resetShadowRoot(vm);\n        // Check that the template was built by the compiler\n        if (!isTemplateRegistered(html)) {\n            throw new ReferenceError(`Invalid template returned by the render() method on ${vm}. It must return an imported template (e.g.: \\`import html from \"./${vm.def.name}.html\"\\`), instead, it has returned: ${toString(html)}.`);\n        }\n        vm.cmpTemplate = html;\n        // Populate context with template information\n        context.tplCache = create(null);\n        resetStyleAttributes(vm);\n        const { stylesheets, stylesheetTokens } = html;\n        if (isUndefined(stylesheets) || stylesheets.length === 0) {\n            context.styleVNode = undefined;\n        }\n        else if (!isUndefined(stylesheetTokens)) {\n            const { hostAttribute, shadowAttribute } = stylesheetTokens;\n            applyStyleAttributes(vm, hostAttribute, shadowAttribute);\n            // Caching style vnode so it can be reused on every render\n            context.styleVNode = evaluateCSS(vm, stylesheets, hostAttribute, shadowAttribute);\n        }\n        if (true) {\n            // one time operation for any new template returned by render()\n            // so we can warn if the template is attempting to use a binding\n            // that is not provided by the component instance.\n            validateFields(vm, html);\n        }\n    }\n    if (true) {\n        assert.isTrue(isObject(context.tplCache), `vm.context.tplCache must be an object associated to ${cmpTemplate}.`);\n        // validating slots in every rendering since the allocated content might change over time\n        validateSlots(vm, html);\n    }\n    const vnodes = html.call(undefined, api$1, component, cmpSlots, context.tplCache);\n    const { styleVNode } = context;\n    if (!isUndefined(context.styleVNode)) {\n        ArrayUnshift.call(vnodes, styleVNode);\n    }\n    if (true) {\n        assert.invariant(isArray(vnodes), `Compiler should produce html functions that always return an array.`);\n    }\n    return vnodes;\n}\n\nvar GlobalMeasurementPhase;\n(function (GlobalMeasurementPhase) {\n    GlobalMeasurementPhase[\"REHYDRATE\"] = \"lwc-rehydrate\";\n    GlobalMeasurementPhase[\"INIT\"] = \"lwc-init\";\n    GlobalMeasurementPhase[\"HYDRATE\"] = \"lwc-hydrate\";\n})(GlobalMeasurementPhase || (GlobalMeasurementPhase = {}));\n// Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.\n// JSDom (used in Jest) for example doesn't implement the UserTiming APIs\nconst isUserTimingSupported = typeof performance !== 'undefined' &&\n    typeof performance.mark === 'function' &&\n    typeof performance.clearMarks === 'function' &&\n    typeof performance.measure === 'function' &&\n    typeof performance.clearMeasures === 'function';\nfunction getMarkName(vm, phase) {\n    return `<${vm.def.name} (${vm.uid})> - ${phase}`;\n}\nfunction startMeasure(vm, phase) {\n    if (!isUserTimingSupported) {\n        return;\n    }\n    const name = getMarkName(vm, phase);\n    performance.mark(name);\n}\nfunction endMeasure(vm, phase) {\n    if (!isUserTimingSupported) {\n        return;\n    }\n    const name = getMarkName(vm, phase);\n    performance.measure(name, name);\n    // Clear the created marks and measure to avoid filling the performance entries buffer.\n    // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.\n    performance.clearMarks(name);\n    performance.clearMeasures(name);\n}\n// tslint:disable-next-line:no-empty\nconst noop$2 = function () { };\nfunction _startGlobalMeasure(phase) {\n    performance.mark(phase);\n}\nfunction _endGlobalMeasure(phase) {\n    performance.measure(phase, phase);\n    performance.clearMarks(phase);\n    performance.clearMeasures(phase);\n}\nfunction _startHydrateMeasure(vm) {\n    performance.mark(getMarkName(vm, GlobalMeasurementPhase.HYDRATE));\n}\nfunction _endHydrateMeasure(vm) {\n    const phase = GlobalMeasurementPhase.HYDRATE;\n    const name = getMarkName(vm, phase);\n    performance.measure(phase, name);\n    performance.clearMarks(name);\n    performance.clearMeasures(phase);\n}\nconst startGlobalMeasure = isUserTimingSupported ? _startGlobalMeasure : noop$2;\nconst endGlobalMeasure = isUserTimingSupported ? _endGlobalMeasure : noop$2;\nconst startHydrateMeasure = isUserTimingSupported ? _startHydrateMeasure : noop$2;\nconst endHydrateMeasure = isUserTimingSupported ? _endHydrateMeasure : noop$2;\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nlet isRendering = false;\nlet vmBeingRendered = null;\nlet vmBeingConstructed = null;\nfunction isBeingConstructed(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    return vmBeingConstructed === vm;\n}\nfunction invokeComponentCallback(vm, fn, args) {\n    const { context, component, callHook } = vm;\n    let result;\n    let error;\n    try {\n        result = callHook(component, fn, args);\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        if (error) {\n            error.wcStack = getErrorComponentStack(vm.elm);\n            // rethrowing the original error annotated after restoring the context\n            throw error; // tslint:disable-line\n        }\n    }\n    return result;\n}\nfunction invokeComponentConstructor(vm, Ctor) {\n    const vmBeingConstructedInception = vmBeingConstructed;\n    vmBeingConstructed = vm;\n    if (true) {\n        startMeasure(vm, 'constructor');\n    }\n    let error;\n    try {\n        new Ctor(); // tslint:disable-line\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        if (true) {\n            endMeasure(vm, 'constructor');\n        }\n        vmBeingConstructed = vmBeingConstructedInception;\n        if (error) {\n            error.wcStack = getErrorComponentStack(vm.elm);\n            // rethrowing the original error annotated after restoring the context\n            throw error; // tslint:disable-line\n        }\n    }\n}\nfunction invokeComponentRenderMethod(vm) {\n    const { def: { render }, callHook } = vm;\n    const { component, context } = vm;\n    const isRenderingInception = isRendering;\n    const vmBeingRenderedInception = vmBeingRendered;\n    isRendering = true;\n    vmBeingRendered = vm;\n    let result;\n    let error;\n    if (true) {\n        startMeasure(vm, 'render');\n    }\n    try {\n        const html = callHook(component, render);\n        result = evaluateTemplate(vm, html);\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        if (true) {\n            endMeasure(vm, 'render');\n        }\n        isRendering = isRenderingInception;\n        vmBeingRendered = vmBeingRenderedInception;\n        if (error) {\n            error.wcStack = getErrorComponentStack(vm.elm);\n            // rethrowing the original error annotated after restoring the context\n            throw error; // tslint:disable-line\n        }\n    }\n    return result || [];\n}\nfunction invokeEventListener(vm, fn, thisValue, event) {\n    const { context, callHook } = vm;\n    let error;\n    try {\n        if (true) {\n            assert.isTrue(isFunction(fn), `Invalid event handler for event '${event.type}' on ${vm}.`);\n        }\n        callHook(thisValue, fn, [event]);\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        if (error) {\n            error.wcStack = getErrorComponentStack(vm.elm);\n            // rethrowing the original error annotated after restoring the context\n            throw error; // tslint:disable-line\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst signedComponentToMetaMap = new Map();\n// chaining this method as a way to wrap existing\n// assignment of component constructor easily, without too much transformation\nfunction registerComponent(Ctor, { name, tmpl: template }) {\n    signedComponentToMetaMap.set(Ctor, { name, template });\n    return Ctor;\n}\nfunction getComponentRegisteredMeta(Ctor) {\n    return signedComponentToMetaMap.get(Ctor);\n}\nfunction createComponent(vm, Ctor) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    // create the component instance\n    invokeComponentConstructor(vm, Ctor);\n    if (isUndefined(vm.component)) {\n        throw new ReferenceError(`Invalid construction for ${Ctor}, you must extend LightningElement.`);\n    }\n}\nfunction linkComponent(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    // wiring service\n    const { def: { wire } } = vm;\n    if (wire) {\n        const { wiring } = Services;\n        if (wiring) {\n            invokeServiceHook(vm, wiring);\n        }\n    }\n}\nfunction clearReactiveListeners(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    const { deps } = vm;\n    const len = deps.length;\n    if (len) {\n        for (let i = 0; i < len; i += 1) {\n            const set = deps[i];\n            const pos = ArrayIndexOf.call(deps[i], vm);\n            if (true) {\n                assert.invariant(pos > -1, `when clearing up deps, the vm must be part of the collection.`);\n            }\n            ArraySplice.call(set, pos, 1);\n        }\n        deps.length = 0;\n    }\n}\nfunction renderComponent(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        assert.invariant(vm.isDirty, `${vm} is not dirty.`);\n    }\n    clearReactiveListeners(vm);\n    const vnodes = invokeComponentRenderMethod(vm);\n    vm.isDirty = false;\n    if (true) {\n        assert.invariant(isArray(vnodes), `${vm}.render() should always return an array of vnodes instead of ${vnodes}`);\n    }\n    return vnodes;\n}\nfunction markComponentAsDirty(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        assert.isFalse(vm.isDirty, `markComponentAsDirty() for ${vm} should not be called when the component is already dirty.`);\n        assert.isFalse(isRendering, `markComponentAsDirty() for ${vm} cannot be called during rendering of ${vmBeingRendered}.`);\n    }\n    vm.isDirty = true;\n}\nconst cmpEventListenerMap = new WeakMap();\nfunction getWrappedComponentsListener(vm, listener) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    if (!isFunction(listener)) {\n        throw new TypeError(); // avoiding problems with non-valid listeners\n    }\n    let wrappedListener = cmpEventListenerMap.get(listener);\n    if (isUndefined(wrappedListener)) {\n        wrappedListener = function (event) {\n            invokeEventListener(vm, listener, undefined, event);\n        };\n        cmpEventListenerMap.set(listener, wrappedListener);\n    }\n    return wrappedListener;\n}\nfunction getComponentAsString(component) {\n    if (false) {}\n    const vm = getComponentVM(component);\n    return `<${StringToLowerCase.call(tagNameGetter.call(vm.elm))}>`;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction apply() {\n    function elemFromPoint(left, top) {\n        const element = elementFromPoint.call(document, left, top);\n        if (isNull(element)) {\n            return element;\n        }\n        return retarget(document, pathComposer(element, true));\n    }\n    // https://github.com/Microsoft/TypeScript/issues/14139\n    document.elementFromPoint = elemFromPoint;\n    // Go until we reach to top of the LWC tree\n    defineProperty(document, 'activeElement', {\n        get() {\n            let node = DocumentPrototypeActiveElement.call(this);\n            if (isNull(node)) {\n                return node;\n            }\n            while (!isUndefined(getNodeOwnerKey$1(node))) {\n                node = parentElementGetter.call(node);\n            }\n            if (node.tagName === 'HTML') { // IE 11. Active element should never be html element\n                node = document.body;\n            }\n            return node;\n        },\n        enumerable: true,\n        configurable: true,\n    });\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n{\n    apply();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect$2() {\n    return typeof window.ShadowRoot === 'undefined';\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction apply$1() {\n    window.ShadowRoot = SyntheticShadowRoot;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (detect$2()) {\n    apply$1();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect$3() {\n    // Don't apply polyfill when ProxyCompat is enabled.\n    if ('getKey' in Proxy) {\n        return false;\n    }\n    const proxy = new Proxy([3, 4], {});\n    const res = [1, 2].concat(proxy);\n    return res.length !== 4;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { isConcatSpreadable } = Symbol;\nconst { isArray: isArray$2 } = Array;\nconst { slice: ArraySlice$1, unshift: ArrayUnshift$1, shift: ArrayShift } = Array.prototype;\nfunction isObject$2(O) {\n    return typeof O === 'object' ? O !== null : typeof O === 'function';\n}\n// https://www.ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable\nfunction isSpreadable(O) {\n    if (!isObject$2(O)) {\n        return false;\n    }\n    const spreadable = O[isConcatSpreadable];\n    return spreadable !== undefined ? Boolean(spreadable) : isArray$2(O);\n}\n// https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat\nfunction ArrayConcatPolyfill(...args) {\n    const O = Object(this);\n    const A = [];\n    let N = 0;\n    const items = ArraySlice$1.call(arguments);\n    ArrayUnshift$1.call(items, O);\n    while (items.length) {\n        const E = ArrayShift.call(items);\n        if (isSpreadable(E)) {\n            let k = 0;\n            const length = E.length;\n            for (k; k < length; k += 1, N += 1) {\n                if (k in E) {\n                    const subElement = E[k];\n                    A[N] = subElement;\n                }\n            }\n        }\n        else {\n            A[N] = E;\n            N += 1;\n        }\n    }\n    return A;\n}\nfunction apply$2() {\n    Array.prototype.concat = ArrayConcatPolyfill;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (detect$3()) {\n    apply$2();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst composedDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');\nfunction detect$4() {\n    if (!composedDescriptor) {\n        // No need to apply this polyfill if this client completely lacks\n        // support for the composed property.\n        return false;\n    }\n    // Assigning a throwaway click event here to suppress a ts error when we\n    // pass clickEvent into the composed getter below. The error is:\n    // [ts] Variable 'clickEvent' is used before being assigned.\n    let clickEvent = new Event('click');\n    const button = document.createElement('button');\n    button.addEventListener('click', event => clickEvent = event);\n    button.click();\n    return !composedDescriptor.get.call(clickEvent);\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst originalClickDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'click');\nfunction handleClick(event) {\n    Object.defineProperty(event, 'composed', {\n        configurable: true,\n        enumerable: true,\n        get() {\n            return true;\n        }\n    });\n}\nfunction apply$3() {\n    HTMLElement.prototype.click = function () {\n        addEventListener.call(this, 'click', handleClick);\n        try {\n            originalClickDescriptor.value.call(this);\n        }\n        catch (ex) {\n            throw ex;\n        }\n        finally {\n            removeEventListener.call(this, 'click', handleClick);\n        }\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (detect$4()) {\n    apply$3();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect$5() {\n    return Object.getOwnPropertyDescriptor(Event.prototype, 'composed') === undefined;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction apply$4() {\n    // https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\n    const composedEvents = assign(create(null), {\n        blur: 1,\n        focus: 1,\n        focusin: 1,\n        focusout: 1,\n        click: 1,\n        dblclick: 1,\n        mousedown: 1,\n        mouseenter: 1,\n        mouseleave: 1,\n        mousemove: 1,\n        mouseout: 1,\n        mouseover: 1,\n        mouseup: 1,\n        wheel: 1,\n        beforeinput: 1,\n        input: 1,\n        keydown: 1,\n        keyup: 1,\n        compositionstart: 1,\n        compositionupdate: 1,\n        compositionend: 1,\n        touchstart: 1,\n        touchend: 1,\n        touchmove: 1,\n        touchcancel: 1,\n        pointerover: 1,\n        pointerenter: 1,\n        pointerdown: 1,\n        pointermove: 1,\n        pointerup: 1,\n        pointercancel: 1,\n        pointerout: 1,\n        pointerleave: 1,\n        gotpointercapture: 1,\n        lostpointercapture: 1,\n        dragstart: 1,\n        drag: 1,\n        dragenter: 1,\n        dragleave: 1,\n        dragover: 1,\n        drop: 1,\n        dragend: 1,\n        DOMActivate: 1,\n        DOMFocusIn: 1,\n        DOMFocusOut: 1,\n        keypress: 1,\n    });\n    // Composed for Native events\n    Object.defineProperties(Event.prototype, {\n        composed: {\n            get() {\n                const { type } = this;\n                return composedEvents[type] === 1;\n            },\n            configurable: true,\n            enumerable: true,\n        },\n    });\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (detect$5()) {\n    apply$4();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst { CustomEvent: OriginalCustomEvent } = window;\nfunction PatchedCustomEvent(type, eventInitDict) {\n    const event = new OriginalCustomEvent(type, eventInitDict);\n    // support for composed on custom events\n    Object.defineProperties(event, {\n        composed: {\n            // We can't use \"value\" here, because IE11 doesn't like mixing and matching\n            // value with get() from Event.prototype.\n            get() {\n                return !!(eventInitDict && eventInitDict.composed);\n            },\n            configurable: true,\n            enumerable: true,\n        },\n    });\n    return event;\n}\nfunction apply$5() {\n    window.CustomEvent = PatchedCustomEvent;\n    window.CustomEvent.prototype = OriginalCustomEvent.prototype;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction detect$6() {\n    // We need to check if CustomEvent is our PatchedCustomEvent because jest\n    // will reset the window object but not constructos and prototypes (e.g.,\n    // Event.prototype).\n    // https://github.com/jsdom/jsdom#shared-constructors-and-prototypes\n    return window.CustomEvent !== PatchedCustomEvent;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nif (detect$6()) {\n    apply$5();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction apply$6 () {\n    const originalComposedGetter = Object.getOwnPropertyDescriptor(Event.prototype, 'composed').get;\n    Object.defineProperties(FocusEvent.prototype, {\n        composed: {\n            get() {\n                const { isTrusted } = this;\n                const composed = originalComposedGetter.call(this);\n                if (isTrusted && composed === false) {\n                    return true;\n                }\n                return composed;\n            },\n            enumerable: true,\n            configurable: true,\n        },\n    });\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n{\n    apply$6();\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/**\n * This is a descriptor map that contains\n * all standard properties that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base HTML Element and\n * Base Lightning Element should support.\n */\nconst HTMLElementOriginalDescriptors = create(null);\nforEach.call(ElementPrototypeAriaPropertyNames, (propName) => {\n    // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n    // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.\n    const descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);\n    if (!isUndefined(descriptor)) {\n        HTMLElementOriginalDescriptors[propName] = descriptor;\n    }\n});\nforEach.call(defaultDefHTMLPropertyNames, (propName) => {\n    // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because\n    // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into\n    // this category, so, better to be sure.\n    const descriptor = getPropertyDescriptor(HTMLElement.prototype, propName);\n    if (!isUndefined(descriptor)) {\n        HTMLElementOriginalDescriptors[propName] = descriptor;\n    }\n});\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst GlobalEvent = Event; // caching global reference to avoid poisoning\n/**\n * This operation is called with a descriptor of an standard html property\n * that a Custom Element can support (including AOM properties), which\n * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors\n * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.\n */\nfunction createBridgeToElementDescriptor(propName, descriptor) {\n    const { get, set, enumerable, configurable } = descriptor;\n    if (!isFunction(get)) {\n        if (true) {\n            assert.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard getter.`);\n        }\n        throw new TypeError();\n    }\n    if (!isFunction(set)) {\n        if (true) {\n            assert.fail(`Detected invalid public property descriptor for HTMLElement.prototype.${propName} definition. Missing the standard setter.`);\n        }\n        throw new TypeError();\n    }\n    return {\n        enumerable,\n        configurable,\n        get() {\n            const vm = getComponentVM(this);\n            if (true) {\n                assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n            }\n            if (isBeingConstructed(vm)) {\n                if (true) {\n                    assert.logError(`${vm} constructor should not read the value of property \"${propName}\". The owner component has not yet set the value. Instead use the constructor to set default values for properties.`, vm.elm);\n                }\n                return;\n            }\n            observeMutation(this, propName);\n            return get.call(vm.elm);\n        },\n        set(newValue) {\n            const vm = getComponentVM(this);\n            if (true) {\n                assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n                assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm}.${propName}`);\n                assert.isFalse(isBeingConstructed(vm), `Failed to construct '${getComponentAsString(this)}': The result must not have attributes.`);\n                assert.invariant(!isObject(newValue) || isNull(newValue), `Invalid value \"${newValue}\" for \"${propName}\" of ${vm}. Value cannot be an object, must be a primitive value.`);\n            }\n            if (newValue !== vm.cmpProps[propName]) {\n                vm.cmpProps[propName] = newValue;\n                if (vm.idx > 0) {\n                    // perf optimization to skip this step if not in the DOM\n                    notifyMutation(this, propName);\n                }\n            }\n            return set.call(vm.elm, newValue);\n        }\n    };\n}\nfunction getLinkedElement(cmp) {\n    return getComponentVM(cmp).elm;\n}\nfunction BaseLightningElement() {\n    // This should be as performant as possible, while any initialization should be done lazily\n    if (isNull(vmBeingConstructed)) {\n        throw new ReferenceError();\n    }\n    if (true) {\n        assert.isTrue(vmBeingConstructed && \"cmpRoot\" in vmBeingConstructed, `${vmBeingConstructed} is not a vm.`);\n        assert.invariant(vmBeingConstructed.elm instanceof HTMLElement, `Component creation requires a DOM element to be associated to ${vmBeingConstructed}.`);\n    }\n    const vm = vmBeingConstructed;\n    const { elm, cmpRoot, uid } = vm;\n    const component = this;\n    vm.component = component;\n    // interaction hooks\n    // We are intentionally hiding this argument from the formal API of LWCElement because\n    // we don't want folks to know about it just yet.\n    if (arguments.length === 1) {\n        const { callHook, setHook, getHook } = arguments[0];\n        vm.callHook = callHook;\n        vm.setHook = setHook;\n        vm.getHook = getHook;\n    }\n    // linking elm, shadow root and component with the VM\n    setHiddenField(component, ViewModelReflection, vm);\n    setInternalField(elm, ViewModelReflection, vm);\n    setInternalField(cmpRoot, ViewModelReflection, vm);\n    setNodeKey(elm, uid);\n    if (true) {\n        patchComponentWithRestrictions(component, EmptyObject);\n        patchShadowRootWithRestrictions(cmpRoot, EmptyObject);\n    }\n}\n// HTML Element - The Good Parts\nBaseLightningElement.prototype = {\n    constructor: BaseLightningElement,\n    dispatchEvent(event) {\n        const elm = getLinkedElement(this);\n        const vm = getComponentVM(this);\n        if (true) {\n            if (arguments.length === 0) {\n                throw new Error(`Failed to execute 'dispatchEvent' on ${getComponentAsString(this)}: 1 argument required, but only 0 present.`);\n            }\n            if (!(event instanceof GlobalEvent)) {\n                throw new Error(`Failed to execute 'dispatchEvent' on ${getComponentAsString(this)}: parameter 1 is not of type 'Event'.`);\n            }\n            const { type: evtName } = event;\n            assert.isFalse(isBeingConstructed(vm), `this.dispatchEvent() should not be called during the construction of the custom element for ${getComponentAsString(this)} because no one is listening for the event \"${evtName}\" just yet.`);\n            if (vm.idx === 0) {\n                assert.logWarning(`Unreachable event \"${evtName}\" dispatched from disconnected element ${getComponentAsString(this)}. Events can only reach the parent element after the element is connected (via connectedCallback) and before the element is disconnected(via disconnectedCallback).`, elm);\n            }\n            if (!evtName.match(/^[a-z]+([a-z0-9]+)?$/)) {\n                assert.logWarning(`Invalid event type \"${evtName}\" dispatched in element ${getComponentAsString(this)}. Event name should only contain lowercase alphanumeric characters.`, elm);\n            }\n        }\n        return dispatchEvent.call(elm, event);\n    },\n    addEventListener(type, listener, options) {\n        const vm = getComponentVM(this);\n        if (true) {\n            assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n            assert.invariant(!isRendering, `${vmBeingRendered}.render() method has side effects on the state of ${vm} by adding an event listener for \"${type}\".`);\n            assert.invariant(isFunction(listener), `Invalid second argument for this.template.addEventListener() in ${vm} for event \"${type}\". Expected an EventListener but received ${listener}.`);\n        }\n        const wrappedListener = getWrappedComponentsListener(vm, listener);\n        vm.elm.addEventListener(type, wrappedListener, options);\n    },\n    removeEventListener(type, listener, options) {\n        const vm = getComponentVM(this);\n        if (true) {\n            assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        }\n        const wrappedListener = getWrappedComponentsListener(vm, listener);\n        vm.elm.removeEventListener(type, wrappedListener, options);\n    },\n    setAttributeNS(ns, attrName, value) {\n        const elm = getLinkedElement(this);\n        if (true) {\n            assert.isFalse(isBeingConstructed(getComponentVM(this)), `Failed to construct '${getComponentAsString(this)}': The result must not have attributes.`);\n        }\n        unlockAttribute(elm, attrName);\n        elm.setAttributeNS.apply(elm, arguments);\n        lockAttribute(elm, attrName);\n    },\n    removeAttributeNS(ns, attrName) {\n        const elm = getLinkedElement(this);\n        unlockAttribute(elm, attrName);\n        elm.removeAttributeNS.apply(elm, arguments);\n        lockAttribute(elm, attrName);\n    },\n    removeAttribute(attrName) {\n        const elm = getLinkedElement(this);\n        unlockAttribute(elm, attrName);\n        elm.removeAttribute.apply(elm, arguments);\n        lockAttribute(elm, attrName);\n    },\n    setAttribute(attrName, value) {\n        const elm = getLinkedElement(this);\n        if (true) {\n            assert.isFalse(isBeingConstructed(getComponentVM(this)), `Failed to construct '${getComponentAsString(this)}': The result must not have attributes.`);\n        }\n        unlockAttribute(elm, attrName);\n        elm.setAttribute.apply(elm, arguments);\n        lockAttribute(elm, attrName);\n    },\n    getAttribute(attrName) {\n        const elm = getLinkedElement(this);\n        unlockAttribute(elm, attrName);\n        const value = elm.getAttribute.apply(elm, arguments);\n        lockAttribute(elm, attrName);\n        return value;\n    },\n    getAttributeNS(ns, attrName) {\n        const elm = getLinkedElement(this);\n        unlockAttribute(elm, attrName);\n        const value = elm.getAttributeNS.apply(elm, arguments);\n        lockAttribute(elm, attrName);\n        return value;\n    },\n    getBoundingClientRect() {\n        const elm = getLinkedElement(this);\n        if (true) {\n            const vm = getComponentVM(this);\n            assert.isFalse(isBeingConstructed(vm), `this.getBoundingClientRect() should not be called during the construction of the custom element for ${getComponentAsString(this)} because the element is not yet in the DOM, instead, you can use it in one of the available life-cycle hooks.`);\n        }\n        return elm.getBoundingClientRect();\n    },\n    /**\n     * Returns the first element that is a descendant of node that\n     * matches selectors.\n     */\n    // querySelector<K extends keyof HTMLElementTagNameMap>(selectors: K): HTMLElementTagNameMap[K] | null;\n    // querySelector<K extends keyof SVGElementTagNameMap>(selectors: K): SVGElementTagNameMap[K] | null;\n    querySelector(selectors) {\n        const vm = getComponentVM(this);\n        if (true) {\n            assert.isFalse(isBeingConstructed(vm), `this.querySelector() cannot be called during the construction of the custom element for ${getComponentAsString(this)} because no children has been added to this element yet.`);\n        }\n        const { elm } = vm;\n        return elm.querySelector(selectors);\n    },\n    /**\n     * Returns all element descendants of node that\n     * match selectors.\n     */\n    // querySelectorAll<K extends keyof HTMLElementTagNameMap>(selectors: K): NodeListOf<HTMLElementTagNameMap[K]>,\n    // querySelectorAll<K extends keyof SVGElementTagNameMap>(selectors: K): NodeListOf<SVGElementTagNameMap[K]>,\n    querySelectorAll(selectors) {\n        const vm = getComponentVM(this);\n        if (true) {\n            assert.isFalse(isBeingConstructed(vm), `this.querySelectorAll() cannot be called during the construction of the custom element for ${getComponentAsString(this)} because no children has been added to this element yet.`);\n        }\n        const { elm } = vm;\n        return elm.querySelectorAll(selectors);\n    },\n    /**\n     * Returns all element descendants of node that\n     * match the provided tagName.\n     */\n    getElementsByTagName(tagNameOrWildCard) {\n        const vm = getComponentVM(this);\n        if (true) {\n            assert.isFalse(isBeingConstructed(vm), `this.getElementsByTagName() cannot be called during the construction of the custom element for ${getComponentAsString(this)} because no children has been added to this element yet.`);\n        }\n        const { elm } = vm;\n        return elm.getElementsByTagName(tagNameOrWildCard);\n    },\n    /**\n     * Returns all element descendants of node that\n     * match the provide classnames.\n     */\n    getElementsByClassName(names) {\n        const vm = getComponentVM(this);\n        if (true) {\n            assert.isFalse(isBeingConstructed(vm), `this.getElementsByClassName() cannot be called during the construction of the custom element for ${getComponentAsString(this)} because no children has been added to this element yet.`);\n        }\n        const { elm } = vm;\n        return elm.getElementsByClassName(names);\n    },\n    get classList() {\n        if (true) {\n            const vm = getComponentVM(this);\n            // TODO: this still fails in dev but works in production, eventually, we should just throw in all modes\n            assert.isFalse(isBeingConstructed(vm), `Failed to construct ${vm}: The result must not have attributes. Adding or tampering with classname in constructor is not allowed in a web component, use connectedCallback() instead.`);\n        }\n        return getLinkedElement(this).classList;\n    },\n    get template() {\n        const vm = getComponentVM(this);\n        if (true) {\n            assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        }\n        return vm.cmpRoot;\n    },\n    get shadowRoot() {\n        // From within the component instance, the shadowRoot is always\n        // reported as \"closed\". Authors should rely on this.template instead.\n        return null;\n    },\n    render() {\n        const vm = getComponentVM(this);\n        const { template } = vm.def;\n        return isUndefined(template) ? defaultEmptyTemplate : template;\n    },\n    toString() {\n        const vm = getComponentVM(this);\n        if (true) {\n            assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        }\n        return `[object ${vm.def.name}]`;\n    },\n};\nconst baseDescriptors = ArrayReduce.call(getOwnPropertyNames(HTMLElementOriginalDescriptors), (descriptors, propName) => {\n    descriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);\n    return descriptors;\n}, create(null));\ndefineProperties(BaseLightningElement.prototype, baseDescriptors);\nif (true) {\n    patchLightningElementPrototypeWithRestrictions(BaseLightningElement.prototype, EmptyObject);\n}\nfreeze(BaseLightningElement);\nseal(BaseLightningElement.prototype);\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// A bridge descriptor is a descriptor whose job is just to get the component instance\n// from the element instance, and get the value or set a new value on the component.\n// This means that across different elements, similar names can get the exact same\n// descriptor, so we can cache them:\nconst cachedGetterByKey = create(null);\nconst cachedSetterByKey = create(null);\nfunction createGetter(key) {\n    let fn = cachedGetterByKey[key];\n    if (isUndefined(fn)) {\n        fn = cachedGetterByKey[key] = function () {\n            const vm = getCustomElementVM(this);\n            const { getHook } = vm;\n            return getHook(vm.component, key);\n        };\n    }\n    return fn;\n}\nfunction createSetter(key) {\n    let fn = cachedSetterByKey[key];\n    if (isUndefined(fn)) {\n        fn = cachedSetterByKey[key] = function (newValue) {\n            const vm = getCustomElementVM(this);\n            const { setHook } = vm;\n            setHook(vm.component, key, newValue);\n        };\n    }\n    return fn;\n}\nfunction createMethodCaller(methodName) {\n    return function () {\n        const vm = getCustomElementVM(this);\n        const { callHook, component } = vm;\n        const fn = component[methodName];\n        return callHook(vm.component, fn, ArraySlice.call(arguments));\n    };\n}\nfunction HTMLBridgeElementFactory(SuperClass, props, methods) {\n    let HTMLBridgeElement;\n    /**\n     * Modern browsers will have all Native Constructors as regular Classes\n     * and must be instantiated with the new keyword. In older browsers,\n     * specifically IE11, those are objects with a prototype property defined,\n     * since they are not supposed to be extended or instantiated with the\n     * new keyword. This forking logic supports both cases, specifically because\n     * wc.ts relies on the construction path of the bridges to create new\n     * fully qualifying web components.\n     */\n    if (isFunction(SuperClass)) {\n        HTMLBridgeElement = class extends SuperClass {\n        };\n    }\n    else {\n        HTMLBridgeElement = function () {\n            // Bridge classes are not supposed to be instantiated directly in\n            // browsers that do not support web components.\n            throw new TypeError('Illegal constructor');\n        };\n        // prototype inheritance dance\n        setPrototypeOf(HTMLBridgeElement, SuperClass);\n        setPrototypeOf(HTMLBridgeElement.prototype, SuperClass.prototype);\n        defineProperty(HTMLBridgeElement.prototype, 'constructor', {\n            writable: true,\n            configurable: true,\n            value: HTMLBridgeElement,\n        });\n    }\n    const descriptors = create(null);\n    // expose getters and setters for each public props on the new Element Bridge\n    for (let i = 0, len = props.length; i < len; i += 1) {\n        const propName = props[i];\n        descriptors[propName] = {\n            get: createGetter(propName),\n            set: createSetter(propName),\n            enumerable: true,\n            configurable: true,\n        };\n    }\n    // expose public methods as props on the new Element Bridge\n    for (let i = 0, len = methods.length; i < len; i += 1) {\n        const methodName = methods[i];\n        descriptors[methodName] = {\n            value: createMethodCaller(methodName),\n            writable: true,\n            configurable: true,\n        };\n    }\n    defineProperties(HTMLBridgeElement.prototype, descriptors);\n    return HTMLBridgeElement;\n}\nconst BaseBridgeElement = HTMLBridgeElementFactory(HTMLElement, getOwnPropertyNames(HTMLElementOriginalDescriptors), []);\nfreeze(BaseBridgeElement);\nseal(BaseBridgeElement.prototype);\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst CtorToDefMap = new WeakMap();\nfunction getCtorProto(Ctor, subclassComponentName) {\n    let proto = getPrototypeOf(Ctor);\n    if (isNull(proto)) {\n        throw new ReferenceError(`Invalid prototype chain for ${subclassComponentName}, you must extend LightningElement.`);\n    }\n    // covering the cases where the ref is circular in AMD\n    if (isCircularModuleDependency(proto)) {\n        const p = resolveCircularModuleDependency(proto);\n        if (true) {\n            if (isNull(p)) {\n                throw new ReferenceError(`Circular module dependency for ${subclassComponentName}, must resolve to a constructor that extends LightningElement.`);\n            }\n        }\n        // escape hatch for Locker and other abstractions to provide their own base class instead\n        // of our Base class without having to leak it to user-land. If the circular function returns\n        // itself, that's the signal that we have hit the end of the proto chain, which must always\n        // be base.\n        proto = p === proto ? BaseLightningElement : p;\n    }\n    return proto;\n}\nfunction isElementComponent(Ctor, subclassComponentName, protoSet) {\n    protoSet = protoSet || [];\n    if (!Ctor || ArrayIndexOf.call(protoSet, Ctor) >= 0) {\n        return false; // null, undefined, or circular prototype definition\n    }\n    const proto = getCtorProto(Ctor, subclassComponentName);\n    if (proto === BaseLightningElement) {\n        return true;\n    }\n    getComponentDef(proto, subclassComponentName); // ensuring that the prototype chain is already expanded\n    ArrayPush.call(protoSet, Ctor);\n    return isElementComponent(proto, subclassComponentName, protoSet);\n}\nfunction createComponentDef(Ctor, meta, subclassComponentName) {\n    if (true) {\n        assert.isTrue(isElementComponent(Ctor, subclassComponentName), `${Ctor} is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration.`);\n        // local to dev block\n        const ctorName = Ctor.name;\n        // Removing the following assert until https://bugs.webkit.org/show_bug.cgi?id=190140 is fixed.\n        // assert.isTrue(ctorName && isString(ctorName), `${toString(Ctor)} should have a \"name\" property with string value, but found ${ctorName}.`);\n        assert.isTrue(Ctor.constructor, `Missing ${ctorName}.constructor, ${ctorName} should have a \"constructor\" property.`);\n    }\n    const { name, template } = meta;\n    let decoratorsMeta = getDecoratorsRegisteredMeta(Ctor);\n    // TODO: eventually, the compiler should do this call directly, but we will also\n    // have to fix all our tests, which are using this declaration manually.\n    if (isUndefined(decoratorsMeta)) {\n        registerDecorators(Ctor, {\n            publicMethods: getOwnValue(Ctor, 'publicMethods'),\n            publicProps: getOwnValue(Ctor, 'publicProps'),\n            track: getOwnValue(Ctor, 'track'),\n            wire: getOwnValue(Ctor, 'wire'),\n        });\n        decoratorsMeta = getDecoratorsRegisteredMeta(Ctor);\n    }\n    let { props, methods, wire, track } = decoratorsMeta || EmptyObject;\n    const proto = Ctor.prototype;\n    let { connectedCallback, disconnectedCallback, renderedCallback, errorCallback, render, } = proto;\n    const superProto = getCtorProto(Ctor, subclassComponentName);\n    const superDef = superProto !== BaseLightningElement ? getComponentDef(superProto, subclassComponentName) : null;\n    const SuperBridge = isNull(superDef) ? BaseBridgeElement : superDef.bridge;\n    const bridge = HTMLBridgeElementFactory(SuperBridge, getOwnPropertyNames(props), getOwnPropertyNames(methods));\n    if (!isNull(superDef)) {\n        props = assign(create(null), superDef.props, props);\n        methods = assign(create(null), superDef.methods, methods);\n        wire = (superDef.wire || wire) ? assign(create(null), superDef.wire, wire) : undefined;\n        track = assign(create(null), superDef.track, track);\n        connectedCallback = connectedCallback || superDef.connectedCallback;\n        disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;\n        renderedCallback = renderedCallback || superDef.renderedCallback;\n        errorCallback = errorCallback || superDef.errorCallback;\n        render = render || superDef.render;\n    }\n    props = assign(create(null), HTML_PROPS, props);\n    const def = {\n        ctor: Ctor,\n        name,\n        wire,\n        track,\n        props,\n        methods,\n        bridge,\n        template,\n        connectedCallback,\n        disconnectedCallback,\n        renderedCallback,\n        errorCallback,\n        render,\n    };\n    if (true) {\n        freeze(Ctor.prototype);\n    }\n    return def;\n}\nfunction isComponentConstructor(Ctor) {\n    return isElementComponent(Ctor, Ctor.name);\n}\nfunction getOwnValue(o, key) {\n    const d = getOwnPropertyDescriptor(o, key);\n    return d && d.value;\n}\nfunction getComponentDef(Ctor, subclassComponentName) {\n    let def = CtorToDefMap.get(Ctor);\n    if (def) {\n        return def;\n    }\n    let meta = getComponentRegisteredMeta(Ctor);\n    if (isUndefined(meta)) {\n        // TODO: remove this workaround:\n        // this is temporary until\n        // all tests are updated to call registerComponent:\n        meta = {\n            template: undefined,\n            name: Ctor.name,\n        };\n    }\n    def = createComponentDef(Ctor, meta, subclassComponentName || Ctor.name);\n    CtorToDefMap.set(Ctor, def);\n    return def;\n}\n/**\n * Returns the component constructor for a given HTMLElement if it can be found\n * @param {HTMLElement} element\n * @return {ComponentConstructor | null}\n */\nfunction getComponentConstructor(elm) {\n    let ctor = null;\n    if (elm instanceof HTMLElement) {\n        const vm = getInternalField(elm, ViewModelReflection);\n        if (!isUndefined(vm)) {\n            ctor = vm.def.ctor;\n        }\n    }\n    return ctor;\n}\n// Only set prototype for public methods and properties\n// No DOM Patching occurs here\nfunction setElementProto(elm, def) {\n    setPrototypeOf(elm, def.bridge.prototype);\n}\nconst HTML_PROPS = ArrayReduce.call(getOwnPropertyNames(HTMLElementOriginalDescriptors), (props, propName) => {\n    const attrName = getAttrNameFromPropName(propName);\n    props[propName] = {\n        config: 3,\n        type: 'any',\n        attr: attrName,\n    };\n    return props;\n}, create(null));\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// Object of type ShadowRoot for instance checks\nconst NativeShadowRoot = window.ShadowRoot;\nconst isNativeShadowRootAvailable$1 = typeof NativeShadowRoot !== \"undefined\";\nlet idx = 0;\nlet uid = 0;\nfunction callHook(cmp, fn, args) {\n    return fn.apply(cmp, args);\n}\nfunction setHook(cmp, prop, newValue) {\n    cmp[prop] = newValue;\n}\nfunction getHook(cmp, prop) {\n    return cmp[prop];\n}\n// DO NOT CHANGE this:\n// these two values are used by the faux-shadow implementation to traverse the DOM\nconst OwnerKey$1 = '$$OwnerKey$$';\nconst OwnKey$1 = '$$OwnKey$$';\nfunction addInsertionIndex(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        assert.invariant(vm.idx === 0, `${vm} is already locked to a previously generated idx.`);\n    }\n    vm.idx = ++idx;\n    const { connected } = Services;\n    if (connected) {\n        invokeServiceHook(vm, connected);\n    }\n    const { connectedCallback } = vm.def;\n    if (!isUndefined(connectedCallback)) {\n        if (true) {\n            startMeasure(vm, 'connectedCallback');\n        }\n        invokeComponentCallback(vm, connectedCallback);\n        if (true) {\n            endMeasure(vm, 'connectedCallback');\n        }\n    }\n}\nfunction removeInsertionIndex(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        assert.invariant(vm.idx > 0, `${vm} is not locked to a previously generated idx.`);\n    }\n    vm.idx = 0;\n    const { disconnected } = Services;\n    if (disconnected) {\n        invokeServiceHook(vm, disconnected);\n    }\n    const { disconnectedCallback } = vm.def;\n    if (!isUndefined(disconnectedCallback)) {\n        if (true) {\n            startMeasure(vm, 'disconnectedCallback');\n        }\n        invokeComponentCallback(vm, disconnectedCallback);\n        if (true) {\n            endMeasure(vm, 'disconnectedCallback');\n        }\n    }\n}\nfunction renderVM(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    if (vm.isDirty) {\n        rehydrate(vm);\n    }\n}\nfunction appendVM(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    if (vm.idx !== 0) {\n        return; // already appended\n    }\n    addInsertionIndex(vm);\n}\nfunction removeVM(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    if (vm.idx === 0) {\n        return; // already removed\n    }\n    removeInsertionIndex(vm);\n    // just in case it comes back, with this we guarantee re-rendering it\n    vm.isDirty = true;\n    clearReactiveListeners(vm);\n    // At this point we need to force the removal of all children because\n    // we don't have a way to know that children custom element were removed\n    // from the DOM. Once we move to use Custom Element APIs, we can remove this\n    // because the disconnectedCallback will be triggered automatically when\n    // removed from the DOM.\n    resetShadowRoot(vm);\n}\nfunction createVM(tagName, elm, Ctor, options) {\n    if (true) {\n        assert.invariant(elm instanceof HTMLElement, `VM creation requires a DOM element instead of ${elm}.`);\n    }\n    const def = getComponentDef(Ctor);\n    const { isRoot, mode, fallback } = options;\n    const shadowRootOptions = {\n        mode,\n        delegatesFocus: !!Ctor.delegatesFocus,\n    };\n    uid += 1;\n    const vm = {\n        uid,\n        idx: 0,\n        isScheduled: false,\n        isDirty: true,\n        isRoot: isTrue(isRoot),\n        fallback,\n        mode,\n        def,\n        elm: elm,\n        data: EmptyObject,\n        context: create(null),\n        cmpProps: create(null),\n        cmpTrack: create(null),\n        cmpState: undefined,\n        cmpSlots: fallback ? create(null) : undefined,\n        cmpTemplate: undefined,\n        cmpRoot: elm.attachShadow(shadowRootOptions),\n        callHook,\n        setHook,\n        getHook,\n        component: undefined,\n        children: EmptyArray,\n        // used to track down all object-key pairs that makes this vm reactive\n        deps: [],\n    };\n    if (true) {\n        vm.toString = () => {\n            return `[object:vm ${def.name} (${vm.idx})]`;\n        };\n    }\n    // create component instance associated to the vm and the element\n    createComponent(vm, Ctor);\n    // link component to the wire service\n    linkComponent(vm);\n}\nfunction rehydrate(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        assert.isTrue(vm.elm instanceof HTMLElement, `rehydration can only happen after ${vm} was patched the first time.`);\n    }\n    if (vm.idx > 0 && vm.isDirty) {\n        const children = renderComponent(vm);\n        vm.isScheduled = false;\n        patchShadowRoot(vm, children);\n        processPostPatchCallbacks(vm);\n    }\n}\nfunction patchErrorBoundaryVm(errorBoundaryVm) {\n    if (true) {\n        assert.isTrue(errorBoundaryVm && \"component\" in errorBoundaryVm, `${errorBoundaryVm} is not a vm.`);\n        assert.isTrue(errorBoundaryVm.elm instanceof HTMLElement, `rehydration can only happen after ${errorBoundaryVm} was patched the first time.`);\n        assert.isTrue(errorBoundaryVm.isDirty, \"rehydration recovery should only happen if vm has updated\");\n    }\n    const children = renderComponent(errorBoundaryVm);\n    const { elm, cmpRoot, fallback, children: oldCh } = errorBoundaryVm;\n    errorBoundaryVm.isScheduled = false;\n    errorBoundaryVm.children = children; // caching the new children collection\n    // patch function mutates vnodes by adding the element reference,\n    // however, if patching fails it contains partial changes.\n    // patch failures are caught in flushRehydrationQueue\n    patchChildren(elm, cmpRoot, oldCh, children, fallback);\n    processPostPatchCallbacks(errorBoundaryVm);\n}\nfunction patchShadowRoot(vm, children) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    const { elm, cmpRoot, fallback, children: oldCh } = vm;\n    vm.children = children; // caching the new children collection\n    if (children.length === 0 && oldCh.length === 0) {\n        return; // nothing to do here\n    }\n    let error;\n    if (true) {\n        startMeasure(vm, 'patch');\n    }\n    try {\n        // patch function mutates vnodes by adding the element reference,\n        // however, if patching fails it contains partial changes.\n        patchChildren(elm, cmpRoot, oldCh, children, fallback);\n    }\n    catch (e) {\n        error = Object(e);\n    }\n    finally {\n        if (true) {\n            endMeasure(vm, 'patch');\n        }\n        if (!isUndefined(error)) {\n            const errorBoundaryVm = getErrorBoundaryVMFromOwnElement(vm);\n            if (isUndefined(errorBoundaryVm)) {\n                throw error; // tslint:disable-line\n            }\n            recoverFromLifeCycleError(vm, errorBoundaryVm, error);\n            // synchronously render error boundary's alternative view\n            // to recover in the same tick\n            if (errorBoundaryVm.isDirty) {\n                patchErrorBoundaryVm(errorBoundaryVm);\n            }\n        }\n    }\n}\nfunction processPostPatchCallbacks(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    const { rendered } = Services;\n    if (rendered) {\n        invokeServiceHook(vm, rendered);\n    }\n    const { renderedCallback } = vm.def;\n    if (!isUndefined(renderedCallback)) {\n        if (true) {\n            startMeasure(vm, 'renderedCallback');\n        }\n        invokeComponentCallback(vm, renderedCallback);\n        if (true) {\n            endMeasure(vm, 'renderedCallback');\n        }\n    }\n}\nlet rehydrateQueue = [];\nfunction flushRehydrationQueue() {\n    startGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);\n    if (true) {\n        assert.invariant(rehydrateQueue.length, `If rehydrateQueue was scheduled, it is because there must be at least one VM on this pending queue instead of ${rehydrateQueue}.`);\n    }\n    const vms = rehydrateQueue.sort((a, b) => a.idx - b.idx);\n    rehydrateQueue = []; // reset to a new queue\n    for (let i = 0, len = vms.length; i < len; i += 1) {\n        const vm = vms[i];\n        try {\n            rehydrate(vm);\n        }\n        catch (error) {\n            const errorBoundaryVm = getErrorBoundaryVMFromParentElement(vm);\n            if (isUndefined(errorBoundaryVm)) {\n                if (i + 1 < len) {\n                    // pieces of the queue are still pending to be rehydrated, those should have priority\n                    if (rehydrateQueue.length === 0) {\n                        addCallbackToNextTick(flushRehydrationQueue);\n                    }\n                    ArrayUnshift.apply(rehydrateQueue, ArraySlice.call(vms, i + 1));\n                }\n                // we need to end the measure before throwing.\n                endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);\n                // rethrowing the original error will break the current tick, but since the next tick is\n                // already scheduled, it should continue patching the rest.\n                throw error; // tslint:disable-line\n            }\n            // we only recover if error boundary is present in the hierarchy\n            recoverFromLifeCycleError(vm, errorBoundaryVm, error);\n            if (errorBoundaryVm.isDirty) {\n                patchErrorBoundaryVm(errorBoundaryVm);\n            }\n        }\n    }\n    endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);\n}\nfunction recoverFromLifeCycleError(failedVm, errorBoundaryVm, error) {\n    if (isUndefined(error.wcStack)) {\n        error.wcStack = getErrorComponentStack(failedVm.elm);\n    }\n    resetShadowRoot(failedVm); // remove offenders\n    const { errorCallback } = errorBoundaryVm.def;\n    if (true) {\n        startMeasure(errorBoundaryVm, 'errorCallback');\n    }\n    // error boundaries must have an ErrorCallback\n    invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);\n    if (true) {\n        endMeasure(errorBoundaryVm, 'errorCallback');\n    }\n}\nfunction destroyChildren(children) {\n    for (let i = 0, len = children.length; i < len; i += 1) {\n        const vnode = children[i];\n        if (isNull(vnode)) {\n            continue;\n        }\n        const { elm } = vnode;\n        if (isUndefined(elm)) {\n            continue;\n        }\n        try {\n            // if destroy fails, it really means that the service hook or disconnect hook failed,\n            // we should just log the issue and continue our destroying procedure\n            vnode.hook.destroy(vnode);\n        }\n        catch (e) {\n            if (true) {\n                const vm = getCustomElementVM(elm);\n                assert.logError(`Internal Error: Failed to disconnect component ${vm}. ${e}`, elm);\n            }\n        }\n    }\n}\n// This is a super optimized mechanism to remove the content of the shadowRoot\n// without having to go into snabbdom. Especially useful when the reset is a consequence\n// of an error, in which case the children VNodes might not be representing the current\n// state of the DOM\nfunction resetShadowRoot(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    const { children: oldCh, fallback } = vm;\n    vm.children = EmptyArray;\n    if (isTrue(fallback)) {\n        // faux-shadow does not have a real cmpRoot instance, instead\n        // we need to remove the content of the host entirely\n        innerHTMLSetter.call(vm.elm, '');\n    }\n    else {\n        ShadowRootInnerHTMLSetter.call(vm.cmpRoot, '');\n    }\n    // proper destroying mechanism for those vnodes that requires it\n    destroyChildren(oldCh);\n}\nfunction scheduleRehydration(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    if (!vm.isScheduled) {\n        vm.isScheduled = true;\n        if (rehydrateQueue.length === 0) {\n            addCallbackToNextTick(flushRehydrationQueue);\n        }\n        ArrayPush.call(rehydrateQueue, vm);\n    }\n}\nfunction getErrorBoundaryVMFromParentElement(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    const { elm } = vm;\n    const parentElm = elm && getParentOrHostElement(elm);\n    return getErrorBoundaryVM(parentElm);\n}\nfunction getErrorBoundaryVMFromOwnElement(vm) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    const { elm } = vm;\n    return getErrorBoundaryVM(elm);\n}\nfunction getErrorBoundaryVM(startingElement) {\n    let elm = startingElement;\n    let vm;\n    while (!isNull(elm)) {\n        vm = getInternalField(elm, ViewModelReflection);\n        if (!isUndefined(vm) && !isUndefined(vm.def.errorCallback)) {\n            return vm;\n        }\n        elm = getParentOrHostElement(elm);\n    }\n}\n/**\n * Returns the component stack. Used for errors messages only.\n *\n * @param {Element} startingElement\n *\n * @return {string} The component stack for errors.\n */\nfunction getErrorComponentStack(startingElement) {\n    const wcStack = [];\n    let elm = startingElement;\n    do {\n        const currentVm = getInternalField(elm, ViewModelReflection);\n        if (!isUndefined(currentVm)) {\n            const tagName = tagNameGetter.call(elm);\n            const is = elm.getAttribute('is');\n            ArrayPush.call(wcStack, `<${StringToLowerCase.call(tagName)}${is ? ' is=\"${is}' : ''}>`);\n        }\n        elm = getParentOrHostElement(elm);\n    } while (!isNull(elm));\n    return wcStack.reverse().join('\\n\\t');\n}\n/**\n * Finds the parent of the specified element. If shadow DOM is enabled, finds\n * the host of the shadow root to escape the shadow boundary.\n * @param {HTMLElement} elm\n * @return {HTMLElement | null} the parent element, escaping any shadow root boundaries, if it exists\n */\nfunction getParentOrHostElement(elm) {\n    const parentElement = parentElementGetter.call(elm);\n    // If this is a shadow root, find the host instead\n    return (isNull(parentElement) && isNativeShadowRootAvailable$1) ? getHostElement(elm) : parentElement;\n}\n/**\n * Finds the host element, if it exists.\n * @param {HTMLElement} elm\n * @return {HTMLElement | null} the host element if it exists\n */\nfunction getHostElement(elm) {\n    if (true) {\n        assert.isTrue(isNativeShadowRootAvailable$1, 'getHostElement should only be called if native shadow root is available');\n        assert.isTrue(isNull(parentElementGetter.call(elm)), `getHostElement should only be called if the parent element of ${elm} is null`);\n    }\n    const parentNode = parentNodeGetter.call(elm);\n    return parentNode instanceof NativeShadowRoot\n        ? ShadowRootHostGetter.call(parentNode)\n        : null;\n}\nfunction isNodeFromTemplate(node) {\n    if (isFalse(node instanceof Node)) {\n        return false;\n    }\n    return !isUndefined(getNodeOwnerKey$1(node));\n}\nfunction getNodeOwnerKey$1(node) {\n    return node[OwnerKey$1];\n}\nfunction setNodeOwnerKey$1(node, value) {\n    if (true) {\n        // in dev-mode, we are more restrictive about what you can do with the owner key\n        defineProperty(node, OwnerKey$1, {\n            value,\n            enumerable: true,\n        });\n    }\n    else {}\n}\nfunction getNodeKey$1(node) {\n    return node[OwnKey$1];\n}\nfunction setNodeKey(node, value) {\n    if (true) {\n        // in dev-mode, we are more restrictive about what you can do with the own key\n        defineProperty(node, OwnKey$1, {\n            value,\n            enumerable: true,\n        });\n    }\n    else {}\n}\nfunction getCustomElementVM(elm) {\n    if (true) {\n        const vm = getInternalField(elm, ViewModelReflection);\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    return getInternalField(elm, ViewModelReflection);\n}\nfunction getComponentVM(component) {\n    if (true) {\n        const vm = getHiddenField(component, ViewModelReflection);\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    return getHiddenField(component, ViewModelReflection);\n}\nfunction getShadowRootVM(root) {\n    // TODO: this eventually should not rely on the symbol, and should use a Weak Ref\n    if (true) {\n        const vm = getInternalField(root, ViewModelReflection);\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n    }\n    return getInternalField(root, ViewModelReflection);\n}\n// slow path routine\n// NOTE: we should probably more this routine to the faux shadow folder\n// and get the allocation to be cached by in the elm instead of in the VM\nfunction allocateInSlot(vm, children) {\n    if (true) {\n        assert.isTrue(vm && \"cmpRoot\" in vm, `${vm} is not a vm.`);\n        assert.invariant(isObject(vm.cmpSlots), `When doing manual allocation, there must be a cmpSlots object available.`);\n    }\n    const { cmpSlots: oldSlots } = vm;\n    const cmpSlots = vm.cmpSlots = create(null);\n    for (let i = 0, len = children.length; i < len; i += 1) {\n        const vnode = children[i];\n        if (isNull(vnode)) {\n            continue;\n        }\n        const data = vnode.data;\n        const slotName = ((data.attrs && data.attrs.slot) || '');\n        const vnodes = cmpSlots[slotName] = cmpSlots[slotName] || [];\n        // re-keying the vnodes is necessary to avoid conflicts with default content for the slot\n        // which might have similar keys. Each vnode will always have a key that\n        // starts with a numeric character from compiler. In this case, we add a unique\n        // notation for slotted vnodes keys, e.g.: `@foo:1:1`\n        vnode.key = `@${slotName}:${vnode.key}`;\n        ArrayPush.call(vnodes, vnode);\n    }\n    if (!vm.isDirty) {\n        // We need to determine if the old allocation is really different from the new one\n        // and mark the vm as dirty\n        const oldKeys = keys(oldSlots);\n        if (oldKeys.length !== keys(cmpSlots).length) {\n            markComponentAsDirty(vm);\n            return;\n        }\n        for (let i = 0, len = oldKeys.length; i < len; i += 1) {\n            const key = oldKeys[i];\n            if (isUndefined(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {\n                markComponentAsDirty(vm);\n                return;\n            }\n            const oldVNodes = oldSlots[key];\n            const vnodes = cmpSlots[key];\n            for (let j = 0, a = cmpSlots[key].length; j < a; j += 1) {\n                if (oldVNodes[j] !== vnodes[j]) {\n                    markComponentAsDirty(vm);\n                    return;\n                }\n            }\n        }\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nconst ConnectingSlot = createFieldName('connecting');\nconst DisconnectingSlot = createFieldName('disconnecting');\nfunction callNodeSlot(node, slot) {\n    if (true) {\n        assert.isTrue(node, `callNodeSlot() should not be called for a non-object`);\n    }\n    const fn = getInternalField(node, slot);\n    if (!isUndefined(fn)) {\n        fn();\n    }\n    return node; // for convenience\n}\n// monkey patching Node methods to be able to detect the insertions and removal of\n// root elements created via createElement.\nassign(Node.prototype, {\n    appendChild(newChild) {\n        const appendedNode = appendChild.call(this, newChild);\n        return callNodeSlot(appendedNode, ConnectingSlot);\n    },\n    insertBefore(newChild, referenceNode) {\n        const insertedNode = insertBefore.call(this, newChild, referenceNode);\n        return callNodeSlot(insertedNode, ConnectingSlot);\n    },\n    removeChild(oldChild) {\n        const removedNode = removeChild.call(this, oldChild);\n        return callNodeSlot(removedNode, DisconnectingSlot);\n    },\n    replaceChild(newChild, oldChild) {\n        const replacedNode = replaceChild.call(this, newChild, oldChild);\n        callNodeSlot(replacedNode, DisconnectingSlot);\n        callNodeSlot(newChild, ConnectingSlot);\n        return replacedNode;\n    },\n});\n/**\n * This method is almost identical to document.createElement\n * (https://developer.mozilla.org/en-US/docs/Web/API/Document/createElement)\n * with the slightly difference that in the options, you can pass the `is`\n * property set to a Constructor instead of just a string value. E.g.:\n *\n * const el = createElement('x-foo', { is: FooCtor });\n *\n * If the value of `is` attribute is not a constructor,\n * then it throws a TypeError.\n */\nfunction createElement$2(sel, options = {}) {\n    if (!isObject(options) || isNull(options)) {\n        throw new TypeError();\n    }\n    let Ctor = options.is;\n    if (isCircularModuleDependency(Ctor)) {\n        Ctor = resolveCircularModuleDependency(Ctor);\n    }\n    let { mode, fallback } = options;\n    // TODO: for now, we default to open, but eventually it should default to 'closed'\n    if (mode !== 'closed') {\n        mode = 'open';\n    }\n    // TODO: for now, we default to true, but eventually it should default to false\n    fallback = isUndefined(fallback) || isTrue(fallback) || isFalse(isNativeShadowRootAvailable);\n    // Create element with correct tagName\n    const element = document.createElement(sel);\n    if (!isUndefined(getNodeKey$1(element))) {\n        // There is a possibility that a custom element is registered under tagName,\n        // in which case, the initialization is already carry on, and there is nothing else\n        // to do here.\n        return element;\n    }\n    const def = getComponentDef(Ctor);\n    setElementProto(element, def);\n    if (isTrue(fallback)) {\n        patchCustomElementProto(element, {\n            def\n        });\n    }\n    if (true) {\n        patchCustomElementWithRestrictions(element, EmptyObject);\n    }\n    // In case the element is not initialized already, we need to carry on the manual creation\n    createVM(sel, element, Ctor, { mode, fallback, isRoot: true });\n    // Handle insertion and removal from the DOM manually\n    setInternalField(element, ConnectingSlot, () => {\n        const vm = getCustomElementVM(element);\n        startHydrateMeasure(vm);\n        removeVM(vm); // moving the element from one place to another is observable via life-cycle hooks\n        appendVM(vm);\n        renderVM(vm);\n        endHydrateMeasure(vm);\n    });\n    setInternalField(element, DisconnectingSlot, () => {\n        const vm = getCustomElementVM(element);\n        removeVM(vm);\n    });\n    return element;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// when used with exactly one argument, we assume it is a function invocation.\nfunction readonly(obj) {\n    if (true) {\n        // TODO: enable the usage of this function as @readonly decorator\n        if (arguments.length !== 1) {\n            assert.fail(\"@readonly cannot be used as a decorator just yet, use it as a function with one argument to produce a readonly version of the provided value.\");\n        }\n    }\n    return reactiveMembrane.getReadOnlyProxy(obj);\n}\n\nfunction buildCustomElementConstructor(Ctor, options) {\n    var _a;\n    if (isCircularModuleDependency(Ctor)) {\n        Ctor = resolveCircularModuleDependency(Ctor);\n    }\n    const { props, bridge: BaseElement } = getComponentDef(Ctor);\n    const normalizedOptions = { fallback: false, mode: 'open', isRoot: true };\n    if (isObject(options) && !isNull(options)) {\n        const { mode, fallback } = options;\n        // TODO: for now, we default to open, but eventually it should default to 'closed'\n        if (mode === 'closed') {\n            normalizedOptions.mode = mode;\n        }\n        // fallback defaults to false to favor shadowRoot\n        normalizedOptions.fallback = isTrue(fallback) || isFalse(isNativeShadowRootAvailable);\n    }\n    return _a = class extends BaseElement {\n            constructor() {\n                super();\n                const tagName = StringToLowerCase.call(tagNameGetter.call(this));\n                if (isTrue(normalizedOptions.fallback)) {\n                    const def = getComponentDef(Ctor);\n                    patchCustomElementProto(this, {\n                        def,\n                    });\n                }\n                createVM(tagName, this, Ctor, normalizedOptions);\n                if (true) {\n                    patchCustomElementWithRestrictions(this, EmptyObject);\n                }\n            }\n            connectedCallback() {\n                const vm = getCustomElementVM(this);\n                appendVM(vm);\n                renderVM(vm);\n            }\n            disconnectedCallback() {\n                const vm = getCustomElementVM(this);\n                removeVM(vm);\n            }\n            attributeChangedCallback(attrName, oldValue, newValue) {\n                if (oldValue === newValue) {\n                    // ignoring similar values for better perf\n                    return;\n                }\n                const propName = getPropNameFromAttrName(attrName);\n                if (isUndefined(props[propName])) {\n                    // ignoring unknown attributes\n                    return;\n                }\n                if (!isAttributeLocked(this, attrName)) {\n                    // ignoring changes triggered by the engine itself during:\n                    // * diffing when public props are attempting to reflect to the DOM\n                    // * component via `this.setAttribute()`, should never update the prop.\n                    // Both cases, the the setAttribute call is always wrap by the unlocking\n                    // of the attribute to be changed\n                    return;\n                }\n                // reflect attribute change to the corresponding props when changed\n                // from outside.\n                this[propName] = newValue;\n            }\n        },\n        // collecting all attribute names from all public props to apply\n        // the reflection from attributes to props via attributeChangedCallback.\n        _a.observedAttributes = ArrayMap.call(getOwnPropertyNames(props), (propName) => props[propName].attr),\n        _a;\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n\n\n/** version: 0.33.26 */\n\n\n//# sourceURL=webpack:///./node_modules/@lwc/engine/dist/modules/es2017/engine.js?");

/***/ }),

/***/ "./node_modules/@lwc/wire-service/dist/modules/es2017/wire.js":
/*!********************************************************************!*\
  !*** ./node_modules/@lwc/wire-service/dist/modules/es2017/wire.js ***!
  \********************************************************************/
/*! exports provided: registerWireService, register, ValueChangedEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"registerWireService\", function() { return registerWireService; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"register\", function() { return register; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValueChangedEvent\", function() { return ValueChangedEvent; });\n/**\n * Copyright (C) 2018 salesforce.com, inc.\n */\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nvar assert = {\n    isTrue(value, msg) {\n        if (!value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    },\n    isFalse(value, msg) {\n        if (value) {\n            throw new Error(`Assert Violation: ${msg}`);\n        }\n    },\n};\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// key in engine service context for wire service context\nconst CONTEXT_ID = '@wire';\n// key in wire service context for updated listener metadata\nconst CONTEXT_UPDATED = 'updated';\n// key in wire service context for connected listener metadata\nconst CONTEXT_CONNECTED = 'connected';\n// key in wire service context for disconnected listener metadata\nconst CONTEXT_DISCONNECTED = 'disconnected';\n// wire event target life cycle connectedCallback hook event type\nconst CONNECT = 'connect';\n// wire event target life cycle disconnectedCallback hook event type\nconst DISCONNECT = 'disconnect';\n// wire event target life cycle config changed hook event type\nconst CONFIG = 'config';\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n/*\n * Detects property changes by installing setter/getter overrides on the component\n * instance.\n *\n * TODO - in 216 engine will expose an 'updated' callback for services that is invoked\n * once after all property changes occur in the event loop.\n */\n/**\n * Invokes the provided change listeners with the resolved component properties.\n * @param configListenerMetadatas List of config listener metadata (config listeners and their context)\n * @param paramValues Values for all wire adapter config params\n */\nfunction invokeConfigListeners(configListenerMetadatas, paramValues) {\n    configListenerMetadatas.forEach((metadata) => {\n        const { listener, statics, reactives } = metadata;\n        const reactiveValues = Object.create(null);\n        if (reactives) {\n            const keys = Object.keys(reactives);\n            for (let j = 0, jlen = keys.length; j < jlen; j++) {\n                const key = keys[j];\n                const value = paramValues[reactives[key]];\n                reactiveValues[key] = value;\n            }\n        }\n        // TODO - consider read-only membrane to enforce invariant of immutable config\n        const config = Object.assign({}, statics, reactiveValues);\n        listener.call(undefined, config);\n    });\n}\n/**\n * Marks a reactive parameter as having changed.\n * @param cmp The component\n * @param reactiveParameter Reactive parameter that has changed\n * @param configContext The service context\n */\nfunction updated(cmp, reactiveParameter, configContext) {\n    if (!configContext.mutated) {\n        configContext.mutated = new Set();\n        // collect all prop changes via a microtask\n        Promise.resolve().then(updatedFuture.bind(undefined, cmp, configContext));\n    }\n    configContext.mutated.add(reactiveParameter);\n}\nfunction updatedFuture(cmp, configContext) {\n    const uniqueListeners = new Set();\n    // configContext.mutated must be set prior to invoking this function\n    const mutated = configContext.mutated;\n    delete configContext.mutated;\n    // pull this variable out of scope to workaround babel minify issue - https://github.com/babel/minify/issues/877\n    let listeners;\n    mutated.forEach(reactiveParameter => {\n        const value = getReactiveParameterValue(cmp, reactiveParameter);\n        if (configContext.values[reactiveParameter.reference] === value) {\n            return;\n        }\n        configContext.values[reactiveParameter.reference] = value;\n        listeners = configContext.listeners[reactiveParameter.head];\n        for (let i = 0, len = listeners.length; i < len; i++) {\n            uniqueListeners.add(listeners[i]);\n        }\n    });\n    invokeConfigListeners(uniqueListeners, configContext.values);\n}\n/**\n * Gets the value of an @wire reactive parameter.\n * @param cmp The component\n * @param reactiveParameter The parameter to get\n */\nfunction getReactiveParameterValue(cmp, reactiveParameter) {\n    let value = cmp[reactiveParameter.head];\n    if (!reactiveParameter.tail) {\n        return value;\n    }\n    const segments = reactiveParameter.tail;\n    for (let i = 0, len = segments.length; i < len && value != null; i++) {\n        const segment = segments[i];\n        if (typeof value !== 'object' || !(segment in value)) {\n            return undefined;\n        }\n        value = value[segment];\n    }\n    return value;\n}\n/**\n * Installs setter override to trap changes to a property, triggering the config listeners.\n * @param cmp The component\n * @param reactiveParameter Reactive parameter that defines the property to monitor\n * @param configContext The service context\n */\nfunction installTrap(cmp, reactiveParameter, configContext) {\n    const callback = updated.bind(undefined, cmp, reactiveParameter, configContext);\n    const newDescriptor = getOverrideDescriptor(cmp, reactiveParameter.head, callback);\n    Object.defineProperty(cmp, reactiveParameter.head, newDescriptor);\n}\n/**\n * Finds the descriptor of the named property on the prototype chain\n * @param target The target instance/constructor function\n * @param propName Name of property to find\n * @param protoSet Prototypes searched (to avoid circular prototype chains)\n */\nfunction findDescriptor(target, propName, protoSet) {\n    protoSet = protoSet || [];\n    if (!target || protoSet.indexOf(target) > -1) {\n        return null; // null, undefined, or circular prototype definition\n    }\n    const descriptor = Object.getOwnPropertyDescriptor(target, propName);\n    if (descriptor) {\n        return descriptor;\n    }\n    const proto = Object.getPrototypeOf(target);\n    if (!proto) {\n        return null;\n    }\n    protoSet.push(target);\n    return findDescriptor(proto, propName, protoSet);\n}\n/**\n * Gets a property descriptor that monitors the provided property for changes\n * @param cmp The component\n * @param prop The name of the property to be monitored\n * @param callback A function to invoke when the prop's value changes\n * @return A property descriptor\n */\nfunction getOverrideDescriptor(cmp, prop, callback) {\n    const descriptor = findDescriptor(cmp, prop);\n    let enumerable;\n    let get;\n    let set;\n    // TODO: this does not cover the override of existing descriptors at the instance level\n    // and that's ok because eventually we will not need to do any of these :)\n    if (descriptor === null || (descriptor.get === undefined && descriptor.set === undefined)) {\n        let value = cmp[prop];\n        enumerable = true;\n        get = function () {\n            return value;\n        };\n        set = function (newValue) {\n            value = newValue;\n            callback();\n        };\n    }\n    else {\n        const { set: originalSet, get: originalGet } = descriptor;\n        enumerable = descriptor.enumerable;\n        set = function (newValue) {\n            if (originalSet) {\n                originalSet.call(cmp, newValue);\n            }\n            callback();\n        };\n        get = function () {\n            return originalGet ? originalGet.call(cmp) : undefined;\n        };\n    }\n    return {\n        set,\n        get,\n        enumerable,\n        configurable: true,\n    };\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\nfunction removeListener(listeners, toRemove) {\n    const idx = listeners.indexOf(toRemove);\n    if (idx > -1) {\n        listeners.splice(idx, 1);\n    }\n}\nfunction removeConfigListener(configListenerMetadatas, toRemove) {\n    for (let i = 0, len = configListenerMetadatas.length; i < len; i++) {\n        if (configListenerMetadatas[i].listener === toRemove) {\n            configListenerMetadatas.splice(i, 1);\n            return;\n        }\n    }\n}\nfunction buildReactiveParameter(reference) {\n    if (!reference.includes('.')) {\n        return {\n            reference,\n            head: reference\n        };\n    }\n    const segments = reference.split('.');\n    return {\n        reference,\n        head: segments.shift(),\n        tail: segments\n    };\n}\nclass WireEventTarget {\n    constructor(cmp, def, context, wireDef, wireTarget) {\n        this._cmp = cmp;\n        this._def = def;\n        this._context = context;\n        this._wireDef = wireDef;\n        this._wireTarget = wireTarget;\n    }\n    addEventListener(type, listener) {\n        switch (type) {\n            case CONNECT:\n                const connectedListeners = this._context[CONTEXT_ID][CONTEXT_CONNECTED];\n                if (true) {\n                    assert.isFalse(connectedListeners.includes(listener), 'must not call addEventListener(\"connect\") with the same listener');\n                }\n                connectedListeners.push(listener);\n                break;\n            case DISCONNECT:\n                const disconnectedListeners = this._context[CONTEXT_ID][CONTEXT_DISCONNECTED];\n                if (true) {\n                    assert.isFalse(disconnectedListeners.includes(listener), 'must not call addEventListener(\"disconnect\") with the same listener');\n                }\n                disconnectedListeners.push(listener);\n                break;\n            case CONFIG:\n                const reactives = this._wireDef.params;\n                const statics = this._wireDef.static;\n                let reactiveKeys;\n                // no reactive parameters. fire config once with static parameters (if present).\n                if (!reactives || (reactiveKeys = Object.keys(reactives)).length === 0) {\n                    const config = statics || Object.create(null);\n                    listener.call(undefined, config);\n                    return;\n                }\n                const configListenerMetadata = {\n                    listener,\n                    statics,\n                    reactives\n                };\n                // setup listeners for all reactive parameters\n                const configContext = this._context[CONTEXT_ID][CONTEXT_UPDATED];\n                reactiveKeys.forEach(key => {\n                    const reactiveParameter = buildReactiveParameter(reactives[key]);\n                    let configListenerMetadatas = configContext.listeners[reactiveParameter.head];\n                    if (!configListenerMetadatas) {\n                        configListenerMetadatas = [configListenerMetadata];\n                        configContext.listeners[reactiveParameter.head] = configListenerMetadatas;\n                        installTrap(this._cmp, reactiveParameter, configContext);\n                    }\n                    else {\n                        configListenerMetadatas.push(configListenerMetadata);\n                    }\n                    // enqueue to pickup default values\n                    updated(this._cmp, reactiveParameter, configContext);\n                });\n                break;\n            default:\n                throw new Error(`unsupported event type ${type}`);\n        }\n    }\n    removeEventListener(type, listener) {\n        switch (type) {\n            case CONNECT:\n                const connectedListeners = this._context[CONTEXT_ID][CONTEXT_CONNECTED];\n                removeListener(connectedListeners, listener);\n                break;\n            case DISCONNECT:\n                const disconnectedListeners = this._context[CONTEXT_ID][CONTEXT_DISCONNECTED];\n                removeListener(disconnectedListeners, listener);\n                break;\n            case CONFIG:\n                const paramToConfigListenerMetadata = this._context[CONTEXT_ID][CONTEXT_UPDATED].listeners;\n                const reactives = this._wireDef.params;\n                if (reactives) {\n                    Object.keys(reactives).forEach(key => {\n                        const reactiveParameter = buildReactiveParameter(reactives[key]);\n                        const configListenerMetadatas = paramToConfigListenerMetadata[reactiveParameter.head];\n                        if (configListenerMetadatas) {\n                            removeConfigListener(configListenerMetadatas, listener);\n                        }\n                    });\n                }\n                break;\n            default:\n                throw new Error(`unsupported event type ${type}`);\n        }\n    }\n    dispatchEvent(evt) {\n        if (evt instanceof ValueChangedEvent) {\n            const value = evt.value;\n            if (this._wireDef.method) {\n                this._cmp[this._wireTarget](value);\n            }\n            else {\n                this._cmp[this._wireTarget] = value;\n            }\n            return false; // canceling signal since we don't want this to propagate\n        }\n        else if (evt.type === 'WireContextEvent') {\n            // NOTE: kill this hack\n            // we should only allow ValueChangedEvent\n            // however, doing so would require adapter to implement machinery\n            // that fire the intended event as DOM event and wrap inside ValueChangedEvent\n            return this._cmp.dispatchEvent(evt);\n        }\n        else {\n            throw new Error(`Invalid event ${evt}.`);\n        }\n    }\n}\n/**\n * Event fired by wire adapters to emit a new value.\n */\nclass ValueChangedEvent {\n    constructor(value) {\n        this.type = 'ValueChangedEvent';\n        this.value = value;\n    }\n}\n\n/*\n * Copyright (c) 2018, salesforce.com, inc.\n * All rights reserved.\n * SPDX-License-Identifier: MIT\n * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT\n */\n// wire adapters: wire adapter id => adapter ctor\nconst adapterFactories = new Map();\n/**\n * Invokes the specified callbacks.\n * @param listeners functions to call\n */\nfunction invokeListener(listeners) {\n    for (let i = 0, len = listeners.length; i < len; ++i) {\n        listeners[i].call(undefined);\n    }\n}\n/**\n * The wire service.\n *\n * This service is registered with the engine's service API. It connects service\n * callbacks to wire adapter lifecycle events.\n */\nconst wireService = {\n    wiring: (cmp, data, def, context) => {\n        const wireContext = context[CONTEXT_ID] = Object.create(null);\n        wireContext[CONTEXT_CONNECTED] = [];\n        wireContext[CONTEXT_DISCONNECTED] = [];\n        wireContext[CONTEXT_UPDATED] = { listeners: {}, values: {} };\n        // engine guarantees invocation only if def.wire is defined\n        const wireStaticDef = def.wire;\n        const wireTargets = Object.keys(wireStaticDef);\n        for (let i = 0, len = wireTargets.length; i < len; i++) {\n            const wireTarget = wireTargets[i];\n            const wireDef = wireStaticDef[wireTarget];\n            const adapterFactory = adapterFactories.get(wireDef.adapter);\n            if (true) {\n                assert.isTrue(wireDef.adapter, `@wire on \"${wireTarget}\": adapter id must be truthy`);\n                assert.isTrue(adapterFactory, `@wire on \"${wireTarget}\": unknown adapter id: ${String(wireDef.adapter)}`);\n                // enforce restrictions of reactive parameters\n                if (wireDef.params) {\n                    Object.keys(wireDef.params).forEach(param => {\n                        const prop = wireDef.params[param];\n                        const segments = prop.split('.');\n                        segments.forEach(segment => {\n                            assert.isTrue(segment.length > 0, `@wire on \"${wireTarget}\": reactive parameters must not be empty`);\n                        });\n                        assert.isTrue(segments[0] !== wireTarget, `@wire on \"${wireTarget}\": reactive parameter \"${segments[0]}\" must not refer to self`);\n                        // restriction for dot-notation reactive parameters\n                        if (segments.length > 1) {\n                            // @wire emits a stream of immutable values. an emit sets the target property; it does not mutate a previously emitted value.\n                            // restricting dot-notation reactive parameters to reference other @wire targets makes trapping the 'head' of the parameter\n                            // sufficient to observe the value change.\n                            assert.isTrue(wireTargets.includes(segments[0]) && wireStaticDef[segments[0]].method !== 1, `@wire on \"${wireTarget}\": dot-notation reactive parameter \"${prop}\" must refer to a @wire property`);\n                        }\n                    });\n                }\n            }\n            if (adapterFactory) {\n                const wireEventTarget = new WireEventTarget(cmp, def, context, wireDef, wireTarget);\n                adapterFactory({\n                    dispatchEvent: wireEventTarget.dispatchEvent.bind(wireEventTarget),\n                    addEventListener: wireEventTarget.addEventListener.bind(wireEventTarget),\n                    removeEventListener: wireEventTarget.removeEventListener.bind(wireEventTarget)\n                });\n            }\n        }\n    },\n    connected: (cmp, data, def, context) => {\n        let listeners;\n        if (!def.wire || !(listeners = context[CONTEXT_ID][CONTEXT_CONNECTED])) {\n            return;\n        }\n        invokeListener(listeners);\n    },\n    disconnected: (cmp, data, def, context) => {\n        let listeners;\n        if (!def.wire || !(listeners = context[CONTEXT_ID][CONTEXT_DISCONNECTED])) {\n            return;\n        }\n        invokeListener(listeners);\n    }\n};\n/**\n * Registers the wire service.\n */\nfunction registerWireService(registerService) {\n    registerService(wireService);\n}\n/**\n * Registers a wire adapter.\n */\nfunction register(adapterId, adapterFactory) {\n    if (true) {\n        assert.isTrue(adapterId, 'adapter id must be truthy');\n        assert.isTrue(typeof adapterFactory === 'function', 'adapter factory must be a callable');\n    }\n    adapterFactories.set(adapterId, adapterFactory);\n}\n\n\n/** version: 0.33.26 */\n\n\n//# sourceURL=webpack:///./node_modules/@lwc/wire-service/dist/modules/es2017/wire.js?");

/***/ }),

/***/ "./node_modules/lwc-webpack-plugin/dist/defaults/empty.css":
/*!*****************************************************************!*\
  !*** ./node_modules/lwc-webpack-plugin/dist/defaults/empty.css ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (undefined);\n\n//# sourceURL=webpack:///./node_modules/lwc-webpack-plugin/dist/defaults/empty.css?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lwc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lwc */ \"./node_modules/@lwc/engine/dist/modules/es2017/engine.js\");\n/* harmony import */ var _lwc_wire_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lwc/wire-service */ \"./node_modules/@lwc/wire-service/dist/modules/es2017/wire.js\");\n/* harmony import */ var _lwc_app_app__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lwc/app/app */ \"./src/lwc/app/app.js\");\n\n\n\n\nObject(_lwc_wire_service__WEBPACK_IMPORTED_MODULE_1__[\"registerWireService\"])(lwc__WEBPACK_IMPORTED_MODULE_0__[\"register\"]);\n\nconst elm = Object(lwc__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])('wire-example', { is: _lwc_app_app__WEBPACK_IMPORTED_MODULE_2__[\"default\"] });\ndocument.body.appendChild(elm);\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/lwc/app/app.html":
/*!******************************!*\
  !*** ./src/lwc/app/app.html ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _app_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app.css */ \"./node_modules/lwc-webpack-plugin/dist/defaults/empty.css\");\n/* harmony import */ var lwc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lwc */ \"./node_modules/@lwc/engine/dist/modules/es2017/engine.js\");\n\n\n\n\nfunction tmpl($api, $cmp, $slotset, $ctx) {\n  const {\n    t: api_text\n  } = $api;\n  return [api_text(\"Hello World\")];\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(lwc__WEBPACK_IMPORTED_MODULE_1__[\"registerTemplate\"])(tmpl));\ntmpl.stylesheets = [];\n\nif (_app_css__WEBPACK_IMPORTED_MODULE_0__[\"default\"]) {\n  tmpl.stylesheets.push.apply(tmpl.stylesheets, _app_css__WEBPACK_IMPORTED_MODULE_0__[\"default\"])\n}\ntmpl.stylesheetTokens = {\n  hostAttribute: \"hey-app_app-host\",\n  shadowAttribute: \"hey-app_app\"\n};\n\n\n//# sourceURL=webpack:///./src/lwc/app/app.html?");

/***/ }),

/***/ "./src/lwc/app/app.js":
/*!****************************!*\
  !*** ./src/lwc/app/app.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var lwc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lwc */ \"./node_modules/@lwc/engine/dist/modules/es2017/engine.js\");\n/* harmony import */ var _app_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./app.html */ \"./src/lwc/app/app.html\");\n/* harmony import */ var _wire_wire__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../../wire/wire */ \"./src/wire/wire.js\");\n\n\n\n\n\n\nclass App extends lwc__WEBPACK_IMPORTED_MODULE_0__[\"LightningElement\"] {\n  constructor(...args) {\n    super(...args);\n    this.wireData = void 0;\n  }\n\n}\n\nObject(lwc__WEBPACK_IMPORTED_MODULE_0__[\"registerDecorators\"])(App, {\n  wire: {\n    wireData: {\n      adapter: _wire_wire__WEBPACK_IMPORTED_MODULE_2__[\"customWire\"],\n      params: {},\n      static: {\n        graphqlQuery: `\n      query(user: $userId) {\n        User {\n          name,\n          id\n        }\n      }\n    `\n      }\n    }\n  }\n})\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(lwc__WEBPACK_IMPORTED_MODULE_0__[\"registerComponent\"])(App, {\n  tmpl: _app_html__WEBPACK_IMPORTED_MODULE_1__[\"default\"]\n}));\n\n//# sourceURL=webpack:///./src/lwc/app/app.js?");

/***/ }),

/***/ "./src/wire/wire.js":
/*!**************************!*\
  !*** ./src/wire/wire.js ***!
  \**************************/
/*! exports provided: customWire */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"customWire\", function() { return customWire; });\n/* harmony import */ var _lwc_wire_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lwc/wire-service */ \"./node_modules/@lwc/wire-service/dist/modules/es2017/wire.js\");\n\n\nconst customWire = () => {}\n\nObject(_lwc_wire_service__WEBPACK_IMPORTED_MODULE_0__[\"register\"])(customWire, (eventTarget) => {\n  eventTarget.addEventListener('config', (config) => {\n    console.log('config from LWC component', config);\n  })\n  \n  eventTarget.addEventListener('disconnect', (config) => {\n    console.log('component disconnected');\n  })\n});\n\n//# sourceURL=webpack:///./src/wire/wire.js?");

/***/ })

/******/ });